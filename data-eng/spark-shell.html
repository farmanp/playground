<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spark Abstractions Lab</title>
    <style>
        :root {
            --bg-primary: #fafbfc;
            --bg-secondary: #ffffff;
            --bg-accent: #f6f8fa;
            --text-primary: #24292f;
            --text-secondary: #656d76;
            --text-muted: #8b949e;
            --border-default: #d0d7de;
            --border-muted: #e1e8ed;
            --accent-emphasis: #0969da;
            --accent-fg: #0550ae;
            --accent-subtle: #ddf4ff;
            --success-emphasis: #1a7f37;
            --attention-emphasis: #9a6700;
            --danger-emphasis: #d1242f;
            --shadow-small: 0 1px 3px rgba(16, 22, 26, 0.1);
            --shadow-medium: 0 4px 6px rgba(16, 22, 26, 0.1);
            --gradient-subtle: linear-gradient(135deg, #f6f8fa 0%, #ffffff 100%);
            --gradient-accent: linear-gradient(135deg, #ddf4ff 0%, #f0f9ff 100%);
            --river-blue: #4285f4;
            --dam-brown: #8d6e63;
            --spill-orange: #ff9800;
            --font-mono: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg-primary: #0d1117;
                --bg-secondary: #161b22;
                --bg-accent: #21262d;
                --text-primary: #e6edf3;
                --text-secondary: #7d8590;
                --text-muted: #656d76;
                --border-default: #30363d;
                --border-muted: #21262d;
                --accent-emphasis: #58a6ff;
                --accent-fg: #79c0ff;
                --accent-subtle: #0c2d6b;
                --success-emphasis: #3fb950;
                --attention-emphasis: #d29922;
                --danger-emphasis: #f85149;
                --shadow-small: 0 1px 3px rgba(1, 4, 9, 0.12);
                --shadow-medium: 0 4px 6px rgba(1, 4, 9, 0.12);
                --gradient-subtle: linear-gradient(135deg, #161b22 0%, #0d1117 100%);
                --gradient-accent: linear-gradient(135deg, #0c2d6b 0%, #1c2e4a 100%);
                --river-blue: #58a6ff;
                --dam-brown: #a1887f;
                --spill-orange: #ffb74d;
            }
        }

        .high-contrast {
            --bg-primary: #ffffff;
            --bg-secondary: #ffffff;
            --bg-accent: #f0f0f0;
            --text-primary: #000000;
            --text-secondary: #000000;
            --text-muted: #666666;
            --border-default: #000000;
            --border-muted: #666666;
            --accent-emphasis: #0000ff;
            --accent-fg: #0000ff;
            --accent-subtle: #e6f3ff;
        }

        @media (prefers-color-scheme: dark) {
            .high-contrast {
                --bg-primary: #000000;
                --bg-secondary: #000000;
                --bg-accent: #1a1a1a;
                --text-primary: #ffffff;
                --text-secondary: #ffffff;
                --text-muted: #cccccc;
                --border-default: #ffffff;
                --border-muted: #cccccc;
                --accent-emphasis: #66b3ff;
                --accent-fg: #66b3ff;
                --accent-subtle: #003d7a;
            }
        }

        .reduced-motion * {
            animation-duration: 0.01ms !important;
            animation-iteration-count: 1 !important;
            transition-duration: 0.01ms !important;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-sans);
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .app-header {
            background: var(--gradient-subtle);
            border-bottom: 1px solid var(--border-default);
            padding: 1rem 2rem;
            box-shadow: var(--shadow-small);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 2rem;
        }

        .app-title {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
            text-decoration: none;
        }

        .app-title:hover {
            color: var(--accent-emphasis);
            transition: color 0.2s ease;
        }

        .app-icon {
            width: 32px;
            height: 32px;
            background: var(--gradient-accent);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.125rem;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .control-button {
            background: var(--bg-secondary);
            border: 1px solid var(--border-default);
            border-radius: 6px;
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .control-button:hover {
            background: var(--bg-accent);
            border-color: var(--accent-emphasis);
            color: var(--text-primary);
        }

        .control-button.active {
            background: var(--accent-subtle);
            border-color: var(--accent-emphasis);
            color: var(--accent-fg);
        }

        .main-container {
            flex: 1;
            display: flex;
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
            min-height: 0;
        }

        .sidebar {
            width: 280px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-default);
            padding: 1.5rem 0;
            overflow-y: auto;
            flex-shrink: 0;
        }

        .sidebar-section {
            margin-bottom: 2rem;
        }

        .sidebar-title {
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.025em;
            color: var(--text-muted);
            padding: 0 1.5rem;
            margin-bottom: 0.75rem;
        }

        .module-list {
            list-style: none;
        }

        .module-item {
            margin-bottom: 0.25rem;
        }

        .module-link {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1.5rem;
            color: var(--text-secondary);
            text-decoration: none;
            border-left: 3px solid transparent;
            transition: all 0.2s ease;
        }

        .module-link:hover {
            background: var(--bg-accent);
            color: var(--text-primary);
            border-left-color: var(--border-default);
        }

        .module-link.active {
            background: var(--accent-subtle);
            color: var(--accent-fg);
            border-left-color: var(--accent-emphasis);
            font-weight: 500;
        }

        .module-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.875rem;
            flex-shrink: 0;
        }

        .module-info {
            flex: 1;
            min-width: 0;
        }

        .module-name {
            font-size: 0.875rem;
            font-weight: 500;
            margin-bottom: 0.125rem;
        }

        .module-subtitle {
            font-size: 0.75rem;
            color: var(--text-muted);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .content-area {
            flex: 1;
            background: var(--bg-primary);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .module-container {
            flex: 1;
            padding: 2rem;
            overflow-y: auto;
        }

        .welcome-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            height: 100%;
            padding: 3rem;
        }

        .welcome-icon {
            width: 80px;
            height: 80px;
            background: var(--gradient-accent);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            margin-bottom: 1.5rem;
        }

        .welcome-title {
            font-size: 1.75rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: var(--text-primary);
        }

        .welcome-subtitle {
            font-size: 1rem;
            color: var(--text-secondary);
            margin-bottom: 2rem;
            max-width: 500px;
        }

        .getting-started {
            background: var(--bg-secondary);
            border: 1px solid var(--border-default);
            border-radius: 8px;
            padding: 1.5rem;
            max-width: 400px;
            width: 100%;
        }

        .getting-started h3 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text-primary);
        }

        .getting-started ul {
            list-style: none;
            space-y: 0.5rem;
        }

        .getting-started li {
            padding: 0.5rem 0;
            color: var(--text-secondary);
            border-bottom: 1px solid var(--border-muted);
        }

        .getting-started li:last-child {
            border-bottom: none;
        }

        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                order: 2;
                border-right: none;
                border-top: 1px solid var(--border-default);
            }
            
            .content-area {
                order: 1;
            }
            
            .header-content {
                padding: 0 1rem;
            }
            
            .module-container {
                padding: 1rem;
            }
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        [role="status"] {
            position: absolute;
            left: -9999px;
            width: 1px;
            height: 1px;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <header class="app-header" role="banner">
        <div class="header-content">
            <a href="#" class="app-title" role="link" aria-label="Spark Abstractions Lab Home">
                <div class="app-icon" aria-hidden="true">âš¡</div>
                <span>Spark Abstractions Lab</span>
            </a>
            
            <div class="header-controls">
                <button class="control-button" id="highContrastToggle" 
                        aria-label="Toggle high contrast mode"
                        role="button">
                    <span aria-hidden="true">ðŸ”†</span>
                    <span>High Contrast</span>
                </button>
                
                <button class="control-button" id="reducedMotionToggle" 
                        aria-label="Toggle reduced motion"
                        role="button">
                    <span aria-hidden="true">ðŸ”„</span>
                    <span>Reduced Motion</span>
                </button>
            </div>
        </div>
    </header>

    <main class="main-container" role="main">
        <nav class="sidebar" role="navigation" aria-label="Module navigation">
            <div class="sidebar-section">
                <h2 class="sidebar-title">Modules</h2>
                <ul class="module-list" id="moduleList" role="list">
                </ul>
            </div>
        </nav>

        <div class="content-area">
            <div class="module-container" id="moduleContainer" role="region" aria-label="Module content">
                <div class="welcome-screen" id="welcomeScreen">
                    <div class="welcome-icon" aria-hidden="true">âš¡</div>
                    <h1 class="welcome-title">Spark Abstractions Lab</h1>
                    <p class="welcome-subtitle">
                        Interactive simulators for understanding Apache Spark's core concepts through visual exploration and hands-on experimentation.
                    </p>
                    <div class="getting-started">
                        <h3>Getting Started</h3>
                        <ul>
                            <li>Select a module from the sidebar to begin</li>
                            <li>Use accessibility controls in the header</li>
                            <li>Each module includes interactive challenges</li>
                            <li>All content works offline</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <div role="status" aria-live="polite" id="ariaStatus"></div>

    <script>
        class SparkLab {
            constructor() {
                this.modules = new Map();
                this.currentModule = null;
                this.currentRoute = null;
                this.eventListeners = new Map();
                
                this.elements = {
                    moduleList: document.getElementById('moduleList'),
                    moduleContainer: document.getElementById('moduleContainer'),
                    welcomeScreen: document.getElementById('welcomeScreen'),
                    ariaStatus: document.getElementById('ariaStatus'),
                    highContrastToggle: document.getElementById('highContrastToggle'),
                    reducedMotionToggle: document.getElementById('reducedMotionToggle')
                };
                
                this.initializeAccessibility();
                this.initializeEventListeners();
                this.loadSettings();
            }

            registerModule(moduleConfig) {
                const { id, title, subtitle, icon, routes, init, tests, about } = moduleConfig;
                
                if (!id || !title || !init) {
                    console.error('Invalid module configuration:', moduleConfig);
                    return false;
                }

                this.modules.set(id, {
                    id,
                    title,
                    subtitle: subtitle || '',
                    icon: icon || 'ðŸ“¦',
                    routes: routes || [{ id: 'main', label: 'Main' }],
                    init,
                    tests: tests || (() => []),
                    about: about || { learningOutcomes: [], references: [] }
                });

                this.renderModuleList();
                this.announceToScreenReader(`Module ${title} registered`);
                return true;
            }

            renderModuleList() {
                this.elements.moduleList.innerHTML = '';
                
                for (const [id, module] of this.modules) {
                    const listItem = document.createElement('li');
                    listItem.className = 'module-item';
                    
                    const link = document.createElement('a');
                    link.href = `#${id}`;
                    link.className = 'module-link';
                    link.setAttribute('data-module-id', id);
                    link.setAttribute('role', 'menuitem');
                    link.setAttribute('aria-describedby', `${id}-description`);
                    
                    if (this.currentModule === id) {
                        link.classList.add('active');
                        link.setAttribute('aria-current', 'page');
                    }
                    
                    link.innerHTML = `
                        <div class="module-icon" aria-hidden="true">${module.icon}</div>
                        <div class="module-info">
                            <div class="module-name">${module.title}</div>
                            <div class="module-subtitle" id="${id}-description">${module.subtitle}</div>
                        </div>
                    `;
                    
                    link.addEventListener('click', (e) => {
                        e.preventDefault();
                        this.loadModule(id);
                    });
                    
                    link.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            this.loadModule(id);
                        }
                    });
                    
                    listItem.appendChild(link);
                    this.elements.moduleList.appendChild(listItem);
                }
            }

            loadModule(moduleId, routeId = null) {
                const module = this.modules.get(moduleId);
                if (!module) {
                    console.error(`Module ${moduleId} not found`);
                    return false;
                }

                this.currentModule = moduleId;
                this.currentRoute = routeId || module.routes[0]?.id || 'main';
                
                this.elements.welcomeScreen.style.display = 'none';
                this.elements.moduleContainer.innerHTML = '';
                
                const moduleElement = document.createElement('div');
                moduleElement.id = `module-${moduleId}`;
                moduleElement.setAttribute('role', 'region');
                moduleElement.setAttribute('aria-label', `${module.title} module`);
                
                this.elements.moduleContainer.appendChild(moduleElement);
                
                const api = this.createModuleAPI(moduleId);
                
                try {
                    module.init(moduleElement, api);
                    this.announceToScreenReader(`Loaded ${module.title} module`);
                    this.renderModuleList();
                    this.updateURL();
                    this.saveSettings();
                } catch (error) {
                    console.error(`Error initializing module ${moduleId}:`, error);
                    this.showError(`Failed to load module: ${module.title}`);
                }
                
                return true;
            }

            createModuleAPI(moduleId) {
                return {
                    emit: (event, data) => {
                        this.emit(`module:${moduleId}:${event}`, data);
                    },
                    subscribe: (event, callback) => {
                        return this.subscribe(`module:${moduleId}:${event}`, callback);
                    },
                    announceToScreenReader: (message) => {
                        this.announceToScreenReader(message);
                    },
                    getCurrentRoute: () => this.currentRoute,
                    navigateToRoute: (routeId) => {
                        this.currentRoute = routeId;
                        this.updateURL();
                    }
                };
            }

            emit(event, data) {
                const listeners = this.eventListeners.get(event) || [];
                listeners.forEach(callback => {
                    try {
                        callback(data);
                    } catch (error) {
                        console.error(`Error in event listener for ${event}:`, error);
                    }
                });
            }

            subscribe(event, callback) {
                if (!this.eventListeners.has(event)) {
                    this.eventListeners.set(event, []);
                }
                this.eventListeners.get(event).push(callback);
                
                return () => {
                    const listeners = this.eventListeners.get(event);
                    if (listeners) {
                        const index = listeners.indexOf(callback);
                        if (index > -1) {
                            listeners.splice(index, 1);
                        }
                    }
                };
            }

            announceToScreenReader(message) {
                this.elements.ariaStatus.textContent = message;
                setTimeout(() => {
                    this.elements.ariaStatus.textContent = '';
                }, 1000);
            }

            showError(message) {
                this.elements.moduleContainer.innerHTML = `
                    <div style="padding: 2rem; text-align: center; color: var(--danger-emphasis);">
                        <h2>Error</h2>
                        <p>${message}</p>
                    </div>
                `;
                this.announceToScreenReader(message);
            }

            initializeAccessibility() {
                this.elements.highContrastToggle.addEventListener('click', () => {
                    document.body.classList.toggle('high-contrast');
                    this.elements.highContrastToggle.classList.toggle('active');
                    const isActive = document.body.classList.contains('high-contrast');
                    this.announceToScreenReader(`High contrast ${isActive ? 'enabled' : 'disabled'}`);
                    this.saveSettings();
                });

                this.elements.reducedMotionToggle.addEventListener('click', () => {
                    document.body.classList.toggle('reduced-motion');
                    this.elements.reducedMotionToggle.classList.toggle('active');
                    const isActive = document.body.classList.contains('reduced-motion');
                    this.announceToScreenReader(`Reduced motion ${isActive ? 'enabled' : 'disabled'}`);
                    this.saveSettings();
                });
            }

            initializeEventListeners() {
                window.addEventListener('hashchange', () => {
                    this.handleRouteChange();
                });
                
                window.addEventListener('load', () => {
                    this.handleRouteChange();
                });
                
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        this.goHome();
                    }
                });
            }

            handleRouteChange() {
                const hash = window.location.hash.slice(1);
                if (!hash) {
                    this.goHome();
                    return;
                }
                
                const [moduleId, routeId] = hash.split('/');
                if (this.modules.has(moduleId)) {
                    this.loadModule(moduleId, routeId);
                } else {
                    this.goHome();
                }
            }

            goHome() {
                this.currentModule = null;
                this.currentRoute = null;
                this.elements.welcomeScreen.style.display = 'flex';
                this.elements.moduleContainer.innerHTML = '';
                this.renderModuleList();
                window.location.hash = '';
                this.announceToScreenReader('Returned to home screen');
            }

            updateURL() {
                if (this.currentModule) {
                    const hash = this.currentRoute 
                        ? `${this.currentModule}/${this.currentRoute}`
                        : this.currentModule;
                    window.location.hash = hash;
                }
            }

            saveSettings() {
                const settings = {
                    highContrast: document.body.classList.contains('high-contrast'),
                    reducedMotion: document.body.classList.contains('reduced-motion'),
                    currentModule: this.currentModule,
                    currentRoute: this.currentRoute
                };
                localStorage.setItem('sparklab-settings', JSON.stringify(settings));
            }

            loadSettings() {
                try {
                    const settings = JSON.parse(localStorage.getItem('sparklab-settings') || '{}');
                    
                    if (settings.highContrast) {
                        document.body.classList.add('high-contrast');
                        this.elements.highContrastToggle.classList.add('active');
                    }
                    
                    if (settings.reducedMotion) {
                        document.body.classList.add('reduced-motion');
                        this.elements.reducedMotionToggle.classList.add('active');
                    }
                } catch (error) {
                    console.error('Error loading settings:', error);
                }
            }

            runAllTests() {
                const results = [];
                for (const [id, module] of this.modules) {
                    const tests = module.tests();
                    for (const test of tests) {
                        try {
                            const passed = test.run();
                            results.push({ module: id, test: test.name, passed });
                        } catch (error) {
                            results.push({ module: id, test: test.name, passed: false, error });
                        }
                    }
                }
                return results;
            }
        }

        window.SparkLab = new SparkLab();

        class RDDLineageModule {
            constructor(element, api) {
                this.element = element;
                this.api = api;
                this.rddCounter = 0;
                this.rdds = new Map();
                this.history = [];
                this.historyIndex = -1;
                this.selectedRdd = null;
                this.challenges = [];
                this.currentChallenge = null;
                
                this.setupDataStructures();
            }

            setupDataStructures() {
                this.operationTemplates = {
                    'map': {
                        name: 'map',
                        type: 'narrow',
                        description: 'Transform each element using a function',
                        codeTemplate: 'rdd.map(x => x * 2)',
                        inputPlaceholder: 'x => x * 2',
                        complexity: 'O(n)'
                    },
                    'filter': {
                        name: 'filter',
                        type: 'narrow',
                        description: 'Keep elements that satisfy a predicate',
                        codeTemplate: 'rdd.filter(x => x > 0)',
                        inputPlaceholder: 'x => x > 0',
                        complexity: 'O(n)'
                    },
                    'flatMap': {
                        name: 'flatMap',
                        type: 'narrow',
                        description: 'Transform and flatten elements',
                        codeTemplate: 'rdd.flatMap(x => [x, x*2])',
                        inputPlaceholder: 'x => [x, x*2]',
                        complexity: 'O(n)'
                    },
                    'groupByKey': {
                        name: 'groupByKey',
                        type: 'wide',
                        description: 'Group values by key (triggers shuffle)',
                        codeTemplate: 'rdd.groupByKey()',
                        inputPlaceholder: '',
                        complexity: 'O(n log n)'
                    },
                    'reduceByKey': {
                        name: 'reduceByKey',
                        type: 'wide',
                        description: 'Reduce values by key (more efficient than groupByKey)',
                        codeTemplate: 'rdd.reduceByKey((a, b) => a + b)',
                        inputPlaceholder: '(a, b) => a + b',
                        complexity: 'O(n log n)'
                    },
                    'join': {
                        name: 'join',
                        type: 'wide',
                        description: 'Inner join two RDDs by key',
                        codeTemplate: 'rdd1.join(rdd2)',
                        inputPlaceholder: '',
                        complexity: 'O(n log n)',
                        requiresSecondRdd: true
                    },
                    'union': {
                        name: 'union',
                        type: 'narrow',
                        description: 'Combine two RDDs (partitions = sum of inputs)',
                        codeTemplate: 'rdd1.union(rdd2)',
                        inputPlaceholder: '',
                        complexity: 'O(1)',
                        requiresSecondRdd: true
                    },
                    'distinct': {
                        name: 'distinct',
                        type: 'wide',
                        description: 'Remove duplicate elements',
                        codeTemplate: 'rdd.distinct()',
                        inputPlaceholder: '',
                        complexity: 'O(n log n)'
                    },
                    'sortBy': {
                        name: 'sortBy',
                        type: 'wide',
                        description: 'Sort elements by key function',
                        codeTemplate: 'rdd.sortBy(x => x)',
                        inputPlaceholder: 'x => x',
                        complexity: 'O(n log n)'
                    }
                };

                this.actionTemplates = {
                    'count': {
                        name: 'count',
                        type: 'action',
                        description: 'Count the number of elements in the RDD',
                        codeTemplate: 'rdd.count()',
                        inputPlaceholder: '',
                        complexity: 'O(n)',
                        triggersStage: true
                    },
                    'collect': {
                        name: 'collect',
                        type: 'action',
                        description: 'Return all elements as an array to the driver',
                        codeTemplate: 'rdd.collect()',
                        inputPlaceholder: '',
                        complexity: 'O(n)',
                        triggersStage: true
                    },
                    'save': {
                        name: 'saveAsTextFile',
                        type: 'action', 
                        description: 'Save RDD to distributed file system',
                        codeTemplate: 'rdd.saveAsTextFile("path")',
                        inputPlaceholder: '"output/path"',
                        complexity: 'O(n)',
                        triggersStage: true
                    }
                };

                this.presets = {
                    'simple-transform': {
                        name: 'Simple Transformations',
                        description: 'Basic map and filter operations',
                        setup: () => this.createSimpleTransformPreset()
                    },
                    'key-value': {
                        name: 'Key-Value Operations',
                        description: 'GroupBy and reduce operations',
                        setup: () => this.createKeyValuePreset()
                    },
                    'join-example': {
                        name: 'Join Operations',
                        description: 'Joining multiple datasets',
                        setup: () => this.createJoinPreset()
                    },
                    'complex-pipeline': {
                        name: 'Complex Pipeline',
                        description: 'Multi-stage transformation chain',
                        setup: () => this.createComplexPreset()
                    }
                };

                this.sampleData = {
                    'numbers': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
                    'words': ['hello', 'world', 'spark', 'rdd', 'lineage'],
                    'pairs': [['a', 1], ['b', 2], ['a', 3], ['c', 4], ['b', 5]],
                    'employees': [['john', 'eng'], ['jane', 'data'], ['bob', 'eng'], ['alice', 'data']],
                    'scores': [['alice', 95], ['bob', 87], ['charlie', 92], ['alice', 88]]
                };
            }

            init() {
                this.render();
                this.setupEventListeners();
                this.createInitialRDD();
                this.setupChallenges();
                this.api.announceToScreenReader('RDD Lineage Visualizer loaded');
            }

            render() {
                this.element.innerHTML = `
                    <div class="rdd-lineage-container">
                        <div class="rdd-toolbar">
                            <div class="toolbar-section">
                                <h1>RDD Lineage Visualizer</h1>
                                <div class="route-tabs">
                                    <button class="route-tab ${this.api.getCurrentRoute() === 'playground' ? 'active' : ''}" 
                                            data-route="playground">Playground</button>
                                    <button class="route-tab ${this.api.getCurrentRoute() === 'challenges' ? 'active' : ''}" 
                                            data-route="challenges">Challenges</button>
                                    <button class="route-tab ${this.api.getCurrentRoute() === 'examples' ? 'active' : ''}" 
                                            data-route="examples">Examples</button>
                                </div>
                            </div>
                            <div class="toolbar-controls">
                                <button id="rdd-reset" class="toolbar-btn" title="Reset to initial state">
                                    <span>ðŸ”„</span> Reset
                                </button>
                                <button id="rdd-undo" class="toolbar-btn" title="Undo last operation">
                                    <span>â†¶</span> Undo
                                </button>
                                <button id="rdd-redo" class="toolbar-btn" title="Redo operation">
                                    <span>â†·</span> Redo
                                </button>
                            </div>
                        </div>

                        <div class="rdd-workspace">
                            <!-- Top Row: DAG Visualizer gets full width -->
                            <div class="rdd-dag-row">
                                <div id="rdd-dag-container" class="dag-container">
                                    <svg id="rdd-dag-svg" class="dag-svg" role="img" aria-label="RDD Lineage Graph">
                                        <defs>
                                            <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                                                    refX="9" refY="3.5" orient="auto">
                                                <polygon points="0 0, 10 3.5, 0 7" fill="var(--text-secondary)" />
                                            </marker>
                                            <filter id="drop-shadow" x="-20%" y="-20%" width="140%" height="140%">
                                                <feDropShadow dx="2" dy="2" stdDeviation="2" flood-opacity="0.1"/>
                                            </filter>
                                        </defs>
                                    </svg>
                                </div>
                            </div>

                            <!-- Bottom Row: Controls and Info Panels -->
                            <div class="rdd-controls-row">
                                <div class="rdd-left-panel">
                                    <div id="rdd-operations-panel" class="panel">
                                        <h3>Operations</h3>
                                        <div class="operation-categories">
                                            <div class="operation-category">
                                                <h4>Transformations</h4>
                                                <div class="operation-grid" id="transformation-ops"></div>
                                            </div>
                                            <div class="operation-category">
                                                <h4>Actions</h4>
                                                <div class="operation-grid" id="action-ops"></div>
                                            </div>
                                            <div class="operation-form" id="operation-form" style="display: none;">
                                                <div class="form-header">
                                                    <h4 id="operation-title"></h4>
                                                    <span class="operation-type" id="operation-type"></span>
                                                </div>
                                                <div class="form-body">
                                                    <div class="input-group" id="operation-inputs"></div>
                                                    <div class="operation-info">
                                                        <div class="complexity" id="operation-complexity"></div>
                                                        <div class="description" id="operation-description"></div>
                                                    </div>
                                                    <div class="form-actions">
                                                        <button id="apply-operation" class="primary-btn">Apply</button>
                                                        <button id="cancel-operation" class="secondary-btn">Cancel</button>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <div id="rdd-presets-panel" class="panel">
                                        <h3>Quick Start</h3>
                                        <div class="preset-grid" id="preset-grid"></div>
                                    </div>
                                </div>

                                <div class="rdd-center-panel">
                                    <div id="rdd-code-preview" class="code-preview">
                                        <h4>Generated Code</h4>
                                        <div class="code-content" id="code-content">
                                            <pre><code>// Select an operation to see the code</code></pre>
                                        </div>
                                    </div>
                                </div>

                                <div class="rdd-right-panel">
                                    <div id="rdd-inspector-panel" class="panel">
                                        <h3>Inspector</h3>
                                        <div id="inspector-content">
                                            <div class="inspector-message">
                                                Click on an RDD node to inspect its properties
                                            </div>
                                        </div>
                                    </div>

                                    <div id="rdd-challenge-panel" class="panel" style="display: none;">
                                        <h3>Challenge</h3>
                                        <div id="challenge-content"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <style>
                        .rdd-lineage-container {
                            height: 100% !important;
                            max-height: 100% !important;
                            display: flex;
                            flex-direction: column;
                            font-family: var(--font-sans);
                            overflow: hidden;
                        }

                        .rdd-toolbar {
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                            padding: 1rem;
                            background: var(--bg-secondary);
                            border-bottom: 1px solid var(--border-default);
                        }

                        .rdd-toolbar h1 {
                            font-size: 1.25rem;
                            font-weight: 600;
                            margin: 0 0 0.5rem 0;
                            color: var(--text-primary);
                        }

                        .route-tabs {
                            display: flex;
                            gap: 0.5rem;
                        }

                        .route-tab {
                            padding: 0.5rem 1rem;
                            border: 1px solid var(--border-default);
                            background: var(--bg-primary);
                            color: var(--text-secondary);
                            cursor: pointer;
                            border-radius: 4px;
                            font-size: 0.875rem;
                            transition: all 0.2s ease;
                        }

                        .route-tab:hover {
                            background: var(--bg-accent);
                            color: var(--text-primary);
                        }

                        .route-tab.active {
                            background: var(--accent-emphasis);
                            color: white;
                            border-color: var(--accent-emphasis);
                        }

                        .toolbar-controls {
                            display: flex;
                            gap: 0.5rem;
                        }

                        .toolbar-btn {
                            padding: 0.5rem 0.75rem;
                            border: 1px solid var(--border-default);
                            background: var(--bg-primary);
                            color: var(--text-secondary);
                            cursor: pointer;
                            border-radius: 4px;
                            font-size: 0.875rem;
                            display: flex;
                            align-items: center;
                            gap: 0.25rem;
                            transition: all 0.2s ease;
                        }

                        .toolbar-btn:hover:not(:disabled) {
                            background: var(--bg-accent);
                            color: var(--text-primary);
                            border-color: var(--accent-emphasis);
                        }

                        .toolbar-btn:disabled {
                            opacity: 0.5;
                            cursor: not-allowed;
                        }

                        .rdd-workspace {
                            flex: 1;
                            display: grid;
                            grid-template-rows: 400px 1fr !important;
                            gap: 1px;
                            background: var(--border-default);
                            min-height: 0;
                            max-height: 100%;
                        }

                        .rdd-dag-row {
                            background: var(--bg-primary);
                            border: 1px solid var(--border-default);
                            margin: 0.5rem;
                            border-radius: 6px;
                            overflow: hidden;
                            width: 100% !important;
                            height: 100% !important;
                            min-height: 0 !important;
                            max-height: 100% !important;
                            position: relative !important;
                            flex: 1 1 50% !important;
                        }

                        .rdd-controls-row {
                            display: grid;
                            grid-template-columns: 300px 1fr 280px !important;
                            gap: 1px;
                            background: var(--border-default);
                        }

                        .rdd-left-panel, .rdd-center-panel, .rdd-right-panel {
                            background: var(--bg-primary);
                            overflow-y: auto;
                            min-width: 0;
                            max-width: 100%;
                        }

                        .panel {
                            padding: 1rem;
                            margin-bottom: 1rem;
                        }

                        .panel h3 {
                            font-size: 1rem;
                            font-weight: 600;
                            margin: 0 0 1rem 0;
                            color: var(--text-primary);
                            border-bottom: 1px solid var(--border-muted);
                            padding-bottom: 0.5rem;
                        }

                        .operation-grid {
                            display: grid;
                            grid-template-columns: 1fr 1fr;
                            gap: 0.5rem;
                            margin-bottom: 1rem;
                        }

                        .operation-btn {
                            padding: 0.75rem;
                            border: 1px solid var(--border-default);
                            background: var(--bg-secondary);
                            color: var(--text-primary);
                            cursor: pointer;
                            border-radius: 6px;
                            font-size: 0.875rem;
                            text-align: center;
                            transition: all 0.2s ease;
                            position: relative;
                        }

                        .operation-btn:hover {
                            background: var(--bg-accent);
                            border-color: var(--accent-emphasis);
                            transform: translateY(-1px);
                        }

                        .operation-btn.wide {
                            border-left: 3px solid var(--attention-emphasis);
                        }

                        .operation-btn.narrow {
                            border-left: 3px solid var(--success-emphasis);
                        }

                        .operation-btn.action {
                            border-left: 3px solid var(--danger-emphasis);
                            background: var(--bg-accent);
                        }

                        .operation-form {
                            background: var(--bg-secondary);
                            border: 1px solid var(--border-default);
                            border-radius: 6px;
                            padding: 1rem;
                            width: 100%;
                            max-width: 100%;
                            box-sizing: border-box;
                        }

                        .form-header {
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                            margin-bottom: 1rem;
                        }

                        .operation-type {
                            padding: 0.25rem 0.5rem;
                            border-radius: 4px;
                            font-size: 0.75rem;
                            font-weight: 500;
                        }

                        .operation-type.wide {
                            background: var(--attention-emphasis);
                            color: white;
                        }

                        .operation-type.narrow {
                            background: var(--success-emphasis);
                            color: white;
                        }

                        .operation-type.action {
                            background: var(--danger-emphasis);
                            color: white;
                        }

                        .input-group {
                            margin-bottom: 1rem;
                        }

                        .input-group label {
                            display: block;
                            margin-bottom: 0.5rem;
                            font-size: 0.875rem;
                            font-weight: 500;
                            color: var(--text-primary);
                        }

                        .input-group input, .input-group select {
                            width: 100%;
                            padding: 0.5rem;
                            border: 1px solid var(--border-default);
                            border-radius: 4px;
                            background: var(--bg-primary);
                            color: var(--text-primary);
                            font-family: var(--font-mono);
                            font-size: 0.875rem;
                        }

                        .input-group input:focus, .input-group select:focus {
                            outline: none;
                            border-color: var(--accent-emphasis);
                            box-shadow: 0 0 0 2px var(--accent-subtle);
                        }

                        .operation-info {
                            margin-bottom: 1rem;
                            padding: 0.75rem;
                            background: var(--bg-accent);
                            border-radius: 4px;
                        }

                        .complexity {
                            font-family: var(--font-mono);
                            font-size: 0.75rem;
                            color: var(--text-muted);
                            margin-bottom: 0.25rem;
                        }

                        .description {
                            font-size: 0.875rem;
                            color: var(--text-secondary);
                        }

                        .form-actions {
                            display: flex;
                            gap: 0.5rem;
                        }

                        .primary-btn, .secondary-btn {
                            flex: 1;
                            padding: 0.75rem;
                            border: 1px solid var(--border-default);
                            border-radius: 4px;
                            cursor: pointer;
                            font-size: 0.875rem;
                            transition: all 0.2s ease;
                        }

                        .primary-btn {
                            background: var(--accent-emphasis);
                            color: white;
                            border-color: var(--accent-emphasis);
                        }

                        .primary-btn:hover {
                            background: var(--accent-fg);
                        }

                        .secondary-btn {
                            background: var(--bg-primary);
                            color: var(--text-secondary);
                        }

                        .secondary-btn:hover {
                            background: var(--bg-accent);
                            color: var(--text-primary);
                        }

                        .preset-grid {
                            display: flex;
                            flex-direction: column;
                            gap: 0.5rem;
                        }

                        .preset-btn {
                            padding: 0.75rem;
                            border: 1px solid var(--border-default);
                            background: var(--bg-secondary);
                            color: var(--text-primary);
                            cursor: pointer;
                            border-radius: 6px;
                            text-align: left;
                            transition: all 0.2s ease;
                        }

                        .preset-btn:hover {
                            background: var(--bg-accent);
                            border-color: var(--accent-emphasis);
                        }

                        .preset-name {
                            font-weight: 500;
                            margin-bottom: 0.25rem;
                        }

                        .preset-desc {
                            font-size: 0.75rem;
                            color: var(--text-muted);
                        }

                        .dag-container {
                            height: 100% !important;
                            width: 100% !important;
                            max-height: 100% !important;
                            max-width: 100% !important;
                            min-height: 0 !important;
                            min-width: 0 !important;
                            position: relative;
                            background: var(--bg-primary);
                            overflow: hidden;
                            flex: none !important;
                        }

                        .dag-svg {
                            width: 100%;
                            height: 100%;
                        }

                        .rdd-node {
                            cursor: pointer;
                            transition: all 0.2s ease;
                        }

                        .rdd-node:hover .rdd-rect {
                            stroke: var(--accent-emphasis);
                            stroke-width: 2;
                        }

                        .rdd-node.selected .rdd-rect {
                            stroke: var(--accent-emphasis);
                            stroke-width: 3;
                            filter: url(#drop-shadow);
                        }

                        .rdd-rect {
                            fill: var(--bg-secondary);
                            stroke: var(--border-default);
                            stroke-width: 3;
                            rx: 8;
                        }

                        .rdd-text {
                            fill: var(--text-primary);
                            font-family: var(--font-sans);
                            font-size: 16px;
                            font-weight: 500;
                            text-anchor: middle;
                            dominant-baseline: middle;
                        }

                        .rdd-operation {
                            fill: var(--text-secondary);
                            font-family: var(--font-mono);
                            font-size: 12px;
                            text-anchor: middle;
                        }

                        .rdd-edge {
                            stroke: var(--text-secondary);
                            stroke-width: 2;
                            fill: none;
                            marker-end: url(#arrowhead);
                        }

                        .rdd-edge.wide {
                            stroke: var(--attention-emphasis);
                            stroke-width: 3;
                            stroke-dasharray: 5,5;
                        }

                        .code-preview {
                            margin: 0.75rem;
                            background: var(--bg-secondary);
                            border: 1px solid var(--border-default);
                            border-radius: 6px;
                            padding: 1rem;
                        }

                        .code-preview h4 {
                            margin: 0 0 0.75rem 0;
                            font-size: 0.875rem;
                            font-weight: 600;
                            color: var(--text-primary);
                        }

                        .code-content {
                            background: var(--bg-accent);
                            border-radius: 4px;
                            padding: 0.75rem;
                        }

                        .code-content pre {
                            margin: 0;
                            font-family: var(--font-mono);
                            font-size: 0.875rem;
                            color: var(--text-primary);
                            white-space: pre-wrap;
                        }

                        .inspector-content {
                            font-size: 0.875rem;
                        }

                        .inspector-message {
                            color: var(--text-muted);
                            text-align: center;
                            padding: 2rem 1rem;
                        }

                        .inspector-property {
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                            padding: 0.5rem 0;
                            border-bottom: 1px solid var(--border-muted);
                        }

                        .inspector-property:last-child {
                            border-bottom: none;
                        }

                        .property-label {
                            font-weight: 500;
                            color: var(--text-primary);
                        }

                        .property-value {
                            color: var(--text-secondary);
                            font-family: var(--font-mono);
                        }

                        .partition-grid {
                            display: grid;
                            grid-template-columns: repeat(auto-fit, minmax(40px, 1fr));
                            gap: 0.25rem;
                            margin-top: 0.5rem;
                        }

                        .partition-cell {
                            aspect-ratio: 1;
                            background: var(--accent-subtle);
                            border: 1px solid var(--accent-emphasis);
                            border-radius: 2px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-size: 0.75rem;
                            color: var(--accent-fg);
                        }

                        @media (max-width: 1024px) {
                            .rdd-workspace {
                                grid-template-columns: 1fr;
                                grid-template-rows: auto 1fr auto;
                            }
                            
                            .rdd-left-panel, .rdd-right-panel {
                                display: flex;
                                overflow-x: auto;
                            }
                            
                            .panel {
                                min-width: 280px;
                                margin-right: 1rem;
                            }
                        }
                    </style>
                `;
            }

            setupEventListeners() {
                const resetBtn = this.element.querySelector('#rdd-reset');
                const undoBtn = this.element.querySelector('#rdd-undo');
                const redoBtn = this.element.querySelector('#rdd-redo');

                resetBtn.addEventListener('click', () => this.resetLineage());
                undoBtn.addEventListener('click', () => this.undo());
                redoBtn.addEventListener('click', () => this.redo());

                this.element.querySelectorAll('.route-tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        const route = e.target.dataset.route;
                        this.switchRoute(route);
                    });
                });

                this.renderOperations();
                this.renderPresets();
                this.updateHistoryButtons();
            }

            createInitialRDD() {
                const initialRdd = {
                    id: 'rdd_0',
                    name: 'Initial Data',
                    operation: 'parallelize',
                    operationType: 'source',
                    data: this.sampleData.numbers,
                    partitions: 4,
                    dependencies: [],
                    cached: false,
                    stageId: 0,
                    isShuffleBoundary: false,
                    x: 280,
                    y: 160
                };

                this.rddCounter = 1;
                this.rdds.set('rdd_0', initialRdd);
                this.saveToHistory();
                this.renderDAG();
                this.generateCode();
                this.selectRdd('rdd_0');
            }

            renderOperations() {
                const transformationContainer = this.element.querySelector('#transformation-ops');
                transformationContainer.innerHTML = '';

                Object.entries(this.operationTemplates).forEach(([key, op]) => {
                    const btn = document.createElement('button');
                    btn.className = `operation-btn ${op.type}`;
                    btn.textContent = op.name;
                    btn.title = op.description;
                    btn.addEventListener('click', () => this.showOperationForm(key, 'transformation'));
                    transformationContainer.appendChild(btn);
                });

                const actionContainer = this.element.querySelector('#action-ops');
                actionContainer.innerHTML = '';

                Object.entries(this.actionTemplates).forEach(([key, op]) => {
                    const btn = document.createElement('button');
                    btn.className = `operation-btn ${op.type}`;
                    btn.textContent = op.name;
                    btn.title = op.description;
                    btn.addEventListener('click', () => this.showOperationForm(key, 'action'));
                    actionContainer.appendChild(btn);
                });
            }

            renderPresets() {
                const container = this.element.querySelector('#preset-grid');
                container.innerHTML = '';

                Object.entries(this.presets).forEach(([key, preset]) => {
                    const btn = document.createElement('button');
                    btn.className = 'preset-btn';
                    btn.innerHTML = `
                        <div class="preset-name">${preset.name}</div>
                        <div class="preset-desc">${preset.description}</div>
                    `;
                    btn.addEventListener('click', () => preset.setup());
                    container.appendChild(btn);
                });
            }

            showOperationForm(operationKey, operationType = 'transformation') {
                const operation = operationType === 'action' 
                    ? this.actionTemplates[operationKey] 
                    : this.operationTemplates[operationKey];
                if (!operation) return;

                const form = this.element.querySelector('#operation-form');
                const title = this.element.querySelector('#operation-title');
                const type = this.element.querySelector('#operation-type');
                const inputs = this.element.querySelector('#operation-inputs');
                const complexity = this.element.querySelector('#operation-complexity');
                const description = this.element.querySelector('#operation-description');

                title.textContent = operation.name;
                type.textContent = operation.type;
                type.className = `operation-type ${operation.type}`;
                complexity.textContent = `Complexity: ${operation.complexity}`;
                description.textContent = operation.description;

                inputs.innerHTML = '';

                if (operation.requiresSecondRdd) {
                    const rddSelect = document.createElement('div');
                    rddSelect.className = 'input-group';
                    rddSelect.innerHTML = `
                        <label for="second-rdd">Select second RDD:</label>
                        <select id="second-rdd">
                            ${Array.from(this.rdds.values()).map(rdd => 
                                `<option value="${rdd.id}">${rdd.name} (${rdd.id})</option>`
                            ).join('')}
                        </select>
                    `;
                    inputs.appendChild(rddSelect);
                }

                if (operation.inputPlaceholder) {
                    const functionInput = document.createElement('div');
                    functionInput.className = 'input-group';
                    functionInput.innerHTML = `
                        <label for="operation-function">Function:</label>
                        <input type="text" id="operation-function" 
                               placeholder="${operation.inputPlaceholder}" 
                               value="${operation.inputPlaceholder}">
                    `;
                    inputs.appendChild(functionInput);
                }

                // Add partition count input for wide transformations
                if (operation.type === 'wide' && operationType === 'transformation') {
                    const partitionInput = document.createElement('div');
                    partitionInput.className = 'input-group';
                    partitionInput.innerHTML = `
                        <label for="num-partitions">Output Partitions:</label>
                        <input type="number" id="num-partitions" 
                               min="1" max="64" value="4" 
                               placeholder="Number of output partitions">
                    `;
                    inputs.appendChild(partitionInput);
                }

                const sourceRddSelect = document.createElement('div');
                sourceRddSelect.className = 'input-group';
                sourceRddSelect.innerHTML = `
                    <label for="source-rdd">Source RDD:</label>
                    <select id="source-rdd">
                        ${Array.from(this.rdds.values()).map(rdd => 
                            `<option value="${rdd.id}" ${rdd.id === this.selectedRdd ? 'selected' : ''}>
                                ${rdd.name} (${rdd.id})
                            </option>`
                        ).join('')}
                    </select>
                `;
                inputs.appendChild(sourceRddSelect);

                form.style.display = 'block';

                this.element.querySelector('#apply-operation').onclick = () => {
                    this.applyOperation(operationKey, operationType);
                };

                this.element.querySelector('#cancel-operation').onclick = () => {
                    form.style.display = 'none';
                };
            }

            applyOperation(operationKey, operationType = 'transformation') {
                const operation = operationType === 'action' 
                    ? this.actionTemplates[operationKey] 
                    : this.operationTemplates[operationKey];
                const sourceRddId = this.element.querySelector('#source-rdd').value;
                const sourceRdd = this.rdds.get(sourceRddId);

                if (!sourceRdd) return;

                if (operationType === 'action') {
                    // Actions trigger stage computation and execution
                    const stages = this.computeStages(sourceRdd);
                    this.showActionResult(operation, sourceRdd, stages);
                    this.element.querySelector('#operation-form').style.display = 'none';
                    return;
                }

                const newRddId = `rdd_${this.rddCounter++}`;
                const newRdd = {
                    id: newRddId,
                    name: `${operation.name}()`,
                    operation: operation.name,
                    operationType: 'transformation',
                    dependencies: [sourceRddId],
                    partitions: this.calculatePartitions(operation, sourceRdd),
                    cached: false,
                    transformationType: operation.type,
                    isShuffleBoundary: operation.type === 'wide',
                    stageId: this.computeStageId(operation, sourceRdd),
                    x: sourceRdd.x + 300,
                    y: sourceRdd.y + (Math.random() - 0.5) * 120
                };

                if (operation.requiresSecondRdd) {
                    const secondRddId = this.element.querySelector('#second-rdd').value;
                    if (secondRddId && secondRddId !== sourceRddId) {
                        newRdd.dependencies.push(secondRddId);
                        const secondRdd = this.rdds.get(secondRddId);
                        newRdd.y = Math.max(sourceRdd.y, secondRdd.y) + 80;
                        
                        // Special handling for join operations
                        if (operation.name === 'join') {
                            newRdd.partitionerId = this.generatePartitionerId(sourceRdd, secondRdd);
                            newRdd.shuffleType = 'hash-shuffle';
                        } else if (operation.name === 'union') {
                            // Union partitions = sum of input partitions
                            newRdd.partitions = sourceRdd.partitions + secondRdd.partitions;
                            newRdd.transformationType = 'narrow'; // Union is narrow
                            newRdd.isShuffleBoundary = false;
                        }
                    }
                }

                if (operation.inputPlaceholder) {
                    const functionInput = this.element.querySelector('#operation-function').value;
                    newRdd.function = functionInput;
                    newRdd.name = `${operation.name}(${functionInput})`;
                }

                this.rdds.set(newRddId, newRdd);
                this.selectedRdd = newRddId;
                
                this.saveToHistory();
                this.renderDAG();
                this.generateCode();
                this.updateInspector(newRddId);
                
                this.element.querySelector('#operation-form').style.display = 'none';
                this.api.announceToScreenReader(`Applied ${operation.name} operation`);
            }

            renderDAG() {
                const svg = this.element.querySelector('#rdd-dag-svg');
                const container = svg.parentElement;
                const containerRect = container.getBoundingClientRect();
                
                // Calculate bounds of all RDDs to set appropriate viewBox
                const rdds = Array.from(this.rdds.values());
                if (rdds.length > 0) {
                    const minX = Math.min(...rdds.map(rdd => rdd.x)) - 50;
                    const maxX = Math.max(...rdds.map(rdd => rdd.x + 300)) + 50;
                    const minY = Math.min(...rdds.map(rdd => rdd.y)) - 50;
                    const maxY = Math.max(...rdds.map(rdd => rdd.y + 100)) + 50;
                    
                    const viewBoxWidth = maxX - minX;
                    const viewBoxHeight = maxY - minY;
                    
                    svg.setAttribute('viewBox', `${minX} ${minY} ${viewBoxWidth} ${viewBoxHeight}`);
                } else {
                    svg.setAttribute('viewBox', '50 50 700 350');
                }
                
                svg.setAttribute('width', '100%');
                svg.setAttribute('height', '100%');
                
                const defs = svg.querySelector('defs');
                svg.innerHTML = defs ? defs.outerHTML : '';
                
                rdds.forEach(rdd => {
                    rdd.dependencies.forEach(depId => {
                        const depRdd = this.rdds.get(depId);
                        if (depRdd) {
                            this.renderEdge(svg, depRdd, rdd);
                        }
                    });
                });

                rdds.forEach(rdd => {
                    this.renderRddNode(svg, rdd);
                });
            }

            renderEdge(svg, fromRdd, toRdd) {
                const fromX = fromRdd.x + 150;
                const fromY = fromRdd.y + 50;
                const toX = toRdd.x;
                const toY = toRdd.y + 50;

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const midX = (fromX + toX) / 2;
                const d = `M ${fromX} ${fromY} C ${midX} ${fromY}, ${midX} ${toY}, ${toX} ${toY}`;
                
                path.setAttribute('d', d);
                path.setAttribute('class', `rdd-edge ${toRdd.transformationType === 'wide' ? 'wide' : ''}`);
                path.setAttribute('aria-label', `Edge from ${fromRdd.name} to ${toRdd.name}`);
                
                svg.appendChild(path);
            }

            renderRddNode(svg, rdd) {
                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                group.setAttribute('class', 'rdd-node');
                group.setAttribute('data-rdd-id', rdd.id);
                group.setAttribute('role', 'button');
                group.setAttribute('aria-label', `RDD ${rdd.name}, click to inspect`);
                group.setAttribute('tabindex', '0');

                if (rdd.id === this.selectedRdd) {
                    group.classList.add('selected');
                }

                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('class', 'rdd-rect');
                rect.setAttribute('x', rdd.x);
                rect.setAttribute('y', rdd.y);
                rect.setAttribute('width', 300);
                rect.setAttribute('height', 100);
                

                const nameText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                nameText.setAttribute('class', 'rdd-text');
                nameText.setAttribute('x', rdd.x + 150);
                nameText.setAttribute('y', rdd.y + 40);
                nameText.textContent = rdd.name.length > 24 ? rdd.name.substring(0, 21) + '...' : rdd.name;

                const idText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                idText.setAttribute('class', 'rdd-operation');
                idText.setAttribute('x', rdd.x + 150);
                idText.setAttribute('y', rdd.y + 70);
                idText.textContent = `${rdd.id} â€¢ ${rdd.partitions}p`;

                group.appendChild(rect);
                group.appendChild(nameText);
                group.appendChild(idText);

                group.addEventListener('click', () => {
                    this.selectRdd(rdd.id);
                });

                group.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        this.selectRdd(rdd.id);
                    }
                });

                svg.appendChild(group);
            }

            selectRdd(rddId) {
                this.selectedRdd = rddId;
                this.renderDAG();
                this.updateInspector(rddId);
                this.api.announceToScreenReader(`Selected RDD ${rddId}`);
            }

            updateInspector(rddId) {
                const rdd = this.rdds.get(rddId);
                const content = this.element.querySelector('#inspector-content');

                if (!rdd) {
                    content.innerHTML = '<div class="inspector-message">RDD not found</div>';
                    return;
                }

                content.innerHTML = `
                    <div class="inspector-property">
                        <span class="property-label">ID</span>
                        <span class="property-value">${rdd.id}</span>
                    </div>
                    <div class="inspector-property">
                        <span class="property-label">Name</span>
                        <span class="property-value">${rdd.name}</span>
                    </div>
                    <div class="inspector-property">
                        <span class="property-label">Operation</span>
                        <span class="property-value">${rdd.operation}</span>
                    </div>
                    <div class="inspector-property">
                        <span class="property-label">Type</span>
                        <span class="property-value">${rdd.operationType}</span>
                    </div>
                    <div class="inspector-property">
                        <span class="property-label">Stage ID</span>
                        <span class="property-value">${rdd.stageId !== undefined ? rdd.stageId : 'N/A'}</span>
                    </div>
                    <div class="inspector-property">
                        <span class="property-label">Partitions</span>
                        <span class="property-value">${rdd.partitions}</span>
                    </div>
                    <div class="inspector-property">
                        <span class="property-label">Output Partitions</span>
                        <span class="property-value">${rdd.partitions}</span>
                    </div>
                    <div class="inspector-property">
                        <span class="property-label">Dependencies</span>
                        <span class="property-value">${rdd.dependencies.length}</span>
                    </div>
                    <div class="inspector-property">
                        <span class="property-label">Shuffle Boundary</span>
                        <span class="property-value">${rdd.isShuffleBoundary ? 'Yes' : 'No'}</span>
                    </div>
                    ${rdd.transformationType ? `
                        <div class="inspector-property">
                            <span class="property-label">Transformation</span>
                            <span class="property-value">${rdd.transformationType}</span>
                        </div>
                    ` : ''}
                    ${rdd.partitionerId ? `
                        <div class="inspector-property">
                            <span class="property-label">Partitioner ID</span>
                            <span class="property-value">${rdd.partitionerId}</span>
                        </div>
                    ` : ''}
                    ${rdd.shuffleType ? `
                        <div class="inspector-property">
                            <span class="property-label">Shuffle Type</span>
                            <span class="property-value">${rdd.shuffleType}</span>
                        </div>
                    ` : ''}
                    ${rdd.function ? `
                        <div class="inspector-property">
                            <span class="property-label">Function</span>
                            <span class="property-value">${rdd.function}</span>
                        </div>
                    ` : ''}
                    <div class="inspector-property">
                        <span class="property-label">Cached</span>
                        <span class="property-value">${rdd.cached ? 'Yes' : 'No'}</span>
                    </div>
                    <div style="margin-top: 1rem;">
                        <div class="property-label">Partition Layout</div>
                        <div class="partition-grid">
                            ${Array.from({length: rdd.partitions}, (_, i) => 
                                `<div class="partition-cell">${i}</div>`
                            ).join('')}
                        </div>
                    </div>
                `;
            }

            generateCode() {
                const content = this.element.querySelector('#code-content');
                let code = '// RDD Lineage Code\n\n';
                
                const rdds = Array.from(this.rdds.values());
                const visited = new Set();
                
                const generateCodeForRdd = (rdd) => {
                    if (visited.has(rdd.id)) return '';
                    visited.add(rdd.id);
                    
                    let rddCode = '';
                    
                    rdd.dependencies.forEach(depId => {
                        const depRdd = this.rdds.get(depId);
                        if (depRdd) {
                            rddCode += generateCodeForRdd(depRdd);
                        }
                    });
                    
                    if (rdd.operation === 'parallelize') {
                        rddCode += `val ${rdd.id} = sc.parallelize(Array(${rdd.data ? rdd.data.slice(0, 5).join(', ') + '...' : 'data'}))\n`;
                    } else if (rdd.dependencies.length === 1) {
                        const sourceRdd = this.rdds.get(rdd.dependencies[0]);
                        const func = rdd.function || '';
                        rddCode += `val ${rdd.id} = ${sourceRdd.id}.${rdd.operation}(${func})\n`;
                    } else if (rdd.dependencies.length === 2) {
                        const sourceRdd1 = this.rdds.get(rdd.dependencies[0]);
                        const sourceRdd2 = this.rdds.get(rdd.dependencies[1]);
                        rddCode += `val ${rdd.id} = ${sourceRdd1.id}.${rdd.operation}(${sourceRdd2.id})\n`;
                    }
                    
                    return rddCode;
                };
                
                rdds.forEach(rdd => {
                    code += generateCodeForRdd(rdd);
                });
                
                content.innerHTML = `<pre><code>${code}</code></pre>`;
            }

            saveToHistory() {
                const state = {
                    rdds: new Map(this.rdds),
                    rddCounter: this.rddCounter,
                    selectedRdd: this.selectedRdd
                };
                
                this.history = this.history.slice(0, this.historyIndex + 1);
                this.history.push(state);
                this.historyIndex = this.history.length - 1;
                this.updateHistoryButtons();
            }

            undo() {
                if (this.historyIndex > 0) {
                    this.historyIndex--;
                    this.restoreFromHistory();
                    this.api.announceToScreenReader('Undid last operation');
                }
            }

            redo() {
                if (this.historyIndex < this.history.length - 1) {
                    this.historyIndex++;
                    this.restoreFromHistory();
                    this.api.announceToScreenReader('Redid operation');
                }
            }

            restoreFromHistory() {
                if (this.historyIndex >= 0 && this.historyIndex < this.history.length) {
                    const state = this.history[this.historyIndex];
                    this.rdds = new Map(state.rdds);
                    this.rddCounter = state.rddCounter;
                    this.selectedRdd = state.selectedRdd;
                    
                    this.renderDAG();
                    this.generateCode();
                    if (this.selectedRdd) {
                        this.updateInspector(this.selectedRdd);
                    }
                    this.updateHistoryButtons();
                }
            }

            updateHistoryButtons() {
                const undoBtn = this.element.querySelector('#rdd-undo');
                const redoBtn = this.element.querySelector('#rdd-redo');
                
                undoBtn.disabled = this.historyIndex <= 0;
                redoBtn.disabled = this.historyIndex >= this.history.length - 1;
            }

            resetLineage() {
                this.rdds.clear();
                this.rddCounter = 0;
                this.selectedRdd = null;
                this.history = [];
                this.historyIndex = -1;
                
                this.createInitialRDD();
                this.api.announceToScreenReader('Reset lineage to initial state');
            }

            switchRoute(route) {
                this.element.querySelectorAll('.route-tab').forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.route === route);
                });
                
                const challengePanel = this.element.querySelector('#rdd-challenge-panel');
                
                if (route === 'challenges') {
                    challengePanel.style.display = 'block';
                    this.showChallenges();
                } else {
                    challengePanel.style.display = 'none';
                }
                
                this.api.navigateToRoute(route);
            }

            setupChallenges() {
                this.challenges = [
                    {
                        id: 'basic-transform',
                        title: 'Basic Transformations',
                        description: 'Apply a map operation to double all numbers, then filter to keep only even numbers.',
                        startState: () => this.createSimpleTransformPreset(),
                        checkSolution: () => {
                            const rdds = Array.from(this.rdds.values());
                            const hasMap = rdds.some(rdd => rdd.operation === 'map');
                            const hasFilter = rdds.some(rdd => rdd.operation === 'filter');
                            return hasMap && hasFilter && rdds.length >= 3;
                        },
                        hint: 'Use the map operation first, then apply filter to the result.'
                    },
                    {
                        id: 'wide-vs-narrow',
                        title: 'Wide vs Narrow',
                        description: 'Create a lineage that includes both narrow and wide transformations. Identify which operations cause shuffles.',
                        startState: () => this.createKeyValuePreset(),
                        checkSolution: () => {
                            const rdds = Array.from(this.rdds.values());
                            const hasNarrow = rdds.some(rdd => rdd.transformationType === 'narrow');
                            const hasWide = rdds.some(rdd => rdd.transformationType === 'wide');
                            return hasNarrow && hasWide;
                        },
                        hint: 'Map and filter are narrow. GroupByKey and join are wide transformations.'
                    },
                    {
                        id: 'optimization',
                        title: 'Optimization Challenge',
                        description: 'Replace a groupByKey operation with reduceByKey for better performance.',
                        startState: () => {
                            this.resetLineage();
                            this.createKeyValuePreset();
                        },
                        checkSolution: () => {
                            const rdds = Array.from(this.rdds.values());
                            const hasReduceByKey = rdds.some(rdd => rdd.operation === 'reduceByKey');
                            const hasNoGroupByKey = !rdds.some(rdd => rdd.operation === 'groupByKey');
                            return hasReduceByKey && hasNoGroupByKey;
                        },
                        hint: 'ReduceByKey is more efficient than groupByKey for aggregations.'
                    }
                ];
            }

            showChallenges() {
                const content = this.element.querySelector('#challenge-content');
                
                if (!this.currentChallenge) {
                    content.innerHTML = `
                        <div class="challenge-list">
                            <h4>Learning Challenges</h4>
                            <p>Test your understanding of RDD lineage concepts:</p>
                            ${this.challenges.map(challenge => `
                                <button class="challenge-btn" data-id="${challenge.id}">
                                    <div class="challenge-title">${challenge.title}</div>
                                    <div class="challenge-desc">${challenge.description}</div>
                                </button>
                            `).join('')}
                        </div>
                        <style>
                            .challenge-list { margin-top: 1rem; }
                            .challenge-btn {
                                width: 100%;
                                padding: 1rem;
                                margin-bottom: 0.5rem;
                                border: 1px solid var(--border-default);
                                background: var(--bg-secondary);
                                color: var(--text-primary);
                                cursor: pointer;
                                border-radius: 6px;
                                text-align: left;
                                transition: all 0.2s ease;
                            }
                            .challenge-btn:hover {
                                background: var(--bg-accent);
                                border-color: var(--accent-emphasis);
                            }
                            .challenge-title {
                                font-weight: 500;
                                margin-bottom: 0.25rem;
                            }
                            .challenge-desc {
                                font-size: 0.875rem;
                                color: var(--text-secondary);
                            }
                        </style>
                    `;
                    
                    // Bind challenge button handlers
                    this.element.querySelectorAll('.challenge-btn').forEach(btn => {
                        btn.addEventListener('click', () => {
                            this.startChallenge(btn.dataset.id);
                        });
                    });
                } else {
                    this.renderCurrentChallenge();
                }
            }

            startChallenge(challengeId) {
                this.currentChallenge = this.challenges.find(c => c.id === challengeId);
                if (this.currentChallenge) {
                    this.currentChallenge.startState();
                    this.renderCurrentChallenge();
                    this.api.announceToScreenReader(`Started challenge: ${this.currentChallenge.title}`);
                }
            }

            renderCurrentChallenge() {
                const content = this.element.querySelector('#challenge-content');
                const isComplete = this.currentChallenge.checkSolution();
                
                content.innerHTML = `
                    <div class="challenge-active">
                        <h4>${this.currentChallenge.title}</h4>
                        <p class="challenge-description">${this.currentChallenge.description}</p>
                        
                        <div class="challenge-status ${isComplete ? 'complete' : 'incomplete'}">
                            <div class="status-indicator">
                                ${isComplete ? 'âœ…' : 'â³'}
                                ${isComplete ? 'Complete!' : 'In Progress'}
                            </div>
                        </div>
                        
                        ${!isComplete ? `
                            <div class="challenge-hint">
                                <strong>Hint:</strong> ${this.currentChallenge.hint}
                            </div>
                        ` : ''}
                        
                        <div class="challenge-actions">
                            <button id="check-challenge-btn" class="check-btn">
                                Check Solution
                            </button>
                            <button id="exit-challenge-btn" class="exit-btn">
                                Exit Challenge
                            </button>
                        </div>
                    </div>
                    
                    <style>
                        .challenge-active { margin-top: 1rem; }
                        .challenge-description {
                            margin: 1rem 0;
                            padding: 1rem;
                            background: var(--bg-accent);
                            border-radius: 4px;
                            font-size: 0.875rem;
                        }
                        .challenge-status {
                            padding: 0.75rem;
                            border-radius: 4px;
                            margin: 1rem 0;
                        }
                        .challenge-status.complete {
                            background: var(--success-emphasis);
                            color: white;
                        }
                        .challenge-status.incomplete {
                            background: var(--attention-emphasis);
                            color: white;
                        }
                        .challenge-hint {
                            padding: 0.75rem;
                            background: var(--accent-subtle);
                            border-radius: 4px;
                            margin: 1rem 0;
                            font-size: 0.875rem;
                            border-left: 3px solid var(--accent-emphasis);
                        }
                        .challenge-actions {
                            display: flex;
                            gap: 0.5rem;
                            margin-top: 1rem;
                        }
                        .check-btn, .exit-btn {
                            flex: 1;
                            padding: 0.75rem;
                            border: 1px solid var(--border-default);
                            border-radius: 4px;
                            cursor: pointer;
                            font-size: 0.875rem;
                            transition: all 0.2s ease;
                        }
                        .check-btn {
                            background: var(--accent-emphasis);
                            color: white;
                            border-color: var(--accent-emphasis);
                        }
                        .check-btn:hover {
                            background: var(--accent-fg);
                        }
                        .exit-btn {
                            background: var(--bg-primary);
                            color: var(--text-secondary);
                        }
                        .exit-btn:hover {
                            background: var(--bg-accent);
                            color: var(--text-primary);
                        }
                    </style>
                `;
                
                // Bind challenge action handlers
                this.element.querySelector('#check-challenge-btn').addEventListener('click', () => {
                    this.checkChallenge();
                });
                this.element.querySelector('#exit-challenge-btn').addEventListener('click', () => {
                    this.exitChallenge();
                });
            }

            checkChallenge() {
                if (this.currentChallenge) {
                    const isComplete = this.currentChallenge.checkSolution();
                    this.renderCurrentChallenge();
                    
                    if (isComplete) {
                        this.api.announceToScreenReader('Challenge completed successfully!');
                    } else {
                        this.api.announceToScreenReader('Challenge not yet complete. Keep working!');
                    }
                }
            }

            exitChallenge() {
                this.currentChallenge = null;
                this.showChallenges();
                this.api.announceToScreenReader('Exited challenge mode');
            }

            createSimpleTransformPreset() {
                this.resetLineage();
            }

            createKeyValuePreset() {
                this.resetLineage();
                
                const pairsRdd = {
                    id: 'rdd_1',
                    name: 'Key-Value Pairs',
                    operation: 'parallelize',
                    operationType: 'source',
                    data: this.sampleData.pairs,
                    partitions: 4,
                    dependencies: [],
                    cached: false,
                    x: 50,
                    y: 150
                };
                
                this.rddCounter = 2;
                this.rdds.clear();
                this.rddCounter = 2;
                this.rdds.set('rdd_1', pairsRdd);
                this.saveToHistory();
                this.renderDAG();
                this.generateCode();
            }

            createJoinPreset() {
                this.resetLineage();
                
                const employees = {
                    id: 'rdd_1',
                    name: 'Employees',
                    operation: 'parallelize',
                    operationType: 'source',
                    data: this.sampleData.employees,
                    partitions: 2,
                    dependencies: [],
                    cached: false,
                    x: 50,
                    y: 100
                };
                
                const scores = {
                    id: 'rdd_2',
                    name: 'Scores',
                    operation: 'parallelize',
                    operationType: 'source',
                    data: this.sampleData.scores,
                    partitions: 2,
                    dependencies: [],
                    cached: false,
                    x: 50,
                    y: 250
                };
                
                this.rddCounter = 3;
                this.rdds.clear();
                this.rdds.set('rdd_1', employees);
                this.rdds.set('rdd_2', scores);
                this.saveToHistory();
                this.renderDAG();
                this.generateCode();
            }

            createComplexPreset() {
                this.resetLineage();
                
                const data = {
                    id: 'rdd_1',
                    name: 'Raw Data',
                    operation: 'textFile',
                    operationType: 'source',
                    data: ['line1', 'line2', 'line3'],
                    partitions: 8,
                    dependencies: [],
                    cached: false,
                    x: 50,
                    y: 150
                };
                
                const words = {
                    id: 'rdd_2',
                    name: 'flatMap(_.split)',
                    operation: 'flatMap',
                    operationType: 'transformation',
                    transformationType: 'narrow',
                    function: '_.split(" ")',
                    dependencies: ['rdd_1'],
                    partitions: 8,
                    cached: false,
                    x: 350,
                    y: 150
                };
                
                const wordCounts = {
                    id: 'rdd_3',
                    name: 'map((_, 1))',
                    operation: 'map',
                    operationType: 'transformation',
                    transformationType: 'narrow',
                    function: 'word => (word, 1)',
                    dependencies: ['rdd_2'],
                    partitions: 8,
                    cached: false,
                    x: 650,
                    y: 150
                };
                
                const reduced = {
                    id: 'rdd_4',
                    name: 'reduceByKey(+)',
                    operation: 'reduceByKey',
                    operationType: 'transformation',
                    transformationType: 'wide',
                    function: '_ + _',
                    dependencies: ['rdd_3'],
                    partitions: 4,
                    cached: true,
                    x: 950,
                    y: 150
                };
                
                this.rddCounter = 5;
                this.rdds.clear();
                this.rdds.set('rdd_1', data);
                this.rdds.set('rdd_2', words);
                this.rdds.set('rdd_3', wordCounts);
                this.rdds.set('rdd_4', reduced);
                this.saveToHistory();
                this.renderDAG();
                this.generateCode();
            }

            // New helper methods for stage computation and enhanced functionality
            calculatePartitions(operation, sourceRdd) {
                if (operation.type === 'wide') {
                    const numPartitionsInput = document.querySelector('#num-partitions');
                    return numPartitionsInput ? parseInt(numPartitionsInput.value) : Math.max(4, sourceRdd.partitions);
                }
                return sourceRdd.partitions;
            }

            computeStageId(operation, sourceRdd) {
                if (operation.type === 'wide') {
                    // Wide transformations create new stages
                    return this.getNextStageId();
                }
                return sourceRdd.stageId || 0;
            }

            getNextStageId() {
                const stageIds = Array.from(this.rdds.values()).map(rdd => rdd.stageId || 0);
                return Math.max(...stageIds, 0) + 1;
            }

            computeStages(targetRdd) {
                const stages = [];
                const visited = new Set();
                
                const traverseStages = (rdd, currentStage = []) => {
                    if (visited.has(rdd.id)) return;
                    visited.add(rdd.id);
                    
                    currentStage.push(rdd);
                    
                    if (rdd.isShuffleBoundary || rdd.operationType === 'source') {
                        stages.push({
                            id: rdd.stageId || stages.length,
                            rdds: [...currentStage],
                            shuffleBoundary: rdd.isShuffleBoundary
                        });
                        currentStage = [];
                    }
                    
                    rdd.dependencies.forEach(depId => {
                        const depRdd = this.rdds.get(depId);
                        if (depRdd) {
                            traverseStages(depRdd, currentStage);
                        }
                    });
                };
                
                traverseStages(targetRdd);
                return stages;
            }

            generatePartitionerId(rdd1, rdd2) {
                // Generate a consistent partitioner ID for join operations
                return `hash-partitioner-${Math.min(rdd1.partitions, rdd2.partitions)}`;
            }

            showActionResult(operation, sourceRdd, stages) {
                const result = {
                    action: operation.name,
                    sourceRdd: sourceRdd.id,
                    stagesTriggered: stages.length,
                    executionPlan: stages
                };
                
                this.api.announceToScreenReader(`Executed ${operation.name} action, triggering ${stages.length} stages`);
                
                // You could show this in a modal or status area
                console.log('Action execution plan:', result);
            }
        }

        window.rddLineageModule = null;

        class DataPartitioningModule {
            constructor(element, api) {
                this.element = element;
                this.api = api;
                this.partitionCount = 4;
                this.currentStrategy = 'hash';
                this.dataItems = [];
                this.partitions = [];
                this.animationSpeed = 1000;
                this.isAnimating = false;
                this.selectedPartition = null;
                this.dataSkew = 0;
                this.currentChallenge = null;
                
                this.setupDataStructures();
            }

            setupDataStructures() {
                this.partitioningStrategies = {
                    'hash': {
                        name: 'Hash Partitioning',
                        description: 'Distributes data using consistent hashing for even distribution',
                        color: '#0969da',
                        partition: (item) => this.hashPartition(item)
                    },
                    'range': {
                        name: 'Range Partitioning', 
                        description: 'Distributes data based on value ranges for sorted access',
                        color: '#1a7f37',
                        partition: (item) => this.rangePartition(item)
                    },
                    'custom': {
                        name: 'Custom Partitioning',
                        description: 'User-defined partitioning logic for specific use cases',
                        color: '#9a6700',
                        partition: (item) => this.customPartition(item)
                    }
                };

                this.sampleDatasets = {
                    'user-ids': {
                        name: 'User IDs',
                        data: Array.from({length: 100}, (_, i) => ({
                            id: `user_${i}`,
                            value: i,
                            type: 'user'
                        }))
                    },
                    'timestamps': {
                        name: 'Timestamps',
                        data: Array.from({length: 100}, (_, i) => ({
                            id: `event_${i}`,
                            value: Date.now() + (i * 60000),
                            type: 'timestamp'
                        }))
                    },
                    'skewed-data': {
                        name: 'Skewed Distribution',
                        data: this.generateSkewedData(100)
                    }
                };

                this.challenges = [
                    {
                        id: 'load-balancer',
                        title: 'Load Balancer',
                        description: 'Distribute skewed data evenly across partitions',
                        dataset: 'skewed-data',
                        goal: 'Achieve <20% variance in partition sizes',
                        validator: () => this.validateLoadBalance(),
                        hint: 'Try different partitioning strategies to minimize skew'
                    },
                    {
                        id: 'hash-master',
                        title: 'Hash Master', 
                        description: 'Predict which partition specific keys will land in',
                        dataset: 'user-ids',
                        goal: 'Correctly predict 8/10 partition assignments',
                        validator: () => this.validateHashPrediction(),
                        hint: 'Hash functions provide consistent, deterministic assignment'
                    },
                    {
                        id: 'range-designer',
                        title: 'Range Designer',
                        description: 'Create optimal range boundaries for time-series data',
                        dataset: 'timestamps',
                        goal: 'Design ranges that enable efficient time-based queries',
                        validator: () => this.validateRangeDesign(),
                        hint: 'Consider query patterns when designing range boundaries'
                    }
                ];
            }

            init() {
                this.render();
                this.setupEventListeners();
                this.initializeData();
                this.api.announceToScreenReader('Data Partitioning module loaded');
            }

            render() {
                this.element.innerHTML = `
                    <div class="partitioning-container">
                        <div class="partitioning-toolbar">
                            <div class="toolbar-section">
                                <h1>Data Partitioning & Distribution</h1>
                                <div class="route-tabs">
                                    <button class="route-tab ${this.api.getCurrentRoute() === 'hash' ? 'active' : ''}" 
                                            data-route="hash">Hash</button>
                                    <button class="route-tab ${this.api.getCurrentRoute() === 'range' ? 'active' : ''}" 
                                            data-route="range">Range</button>
                                    <button class="route-tab ${this.api.getCurrentRoute() === 'custom' ? 'active' : ''}" 
                                            data-route="custom">Custom</button>
                                    <button class="route-tab ${this.api.getCurrentRoute() === 'challenges' ? 'active' : ''}" 
                                            data-route="challenges">Challenges</button>
                                </div>
                            </div>
                            
                            <div class="toolbar-controls">
                                <button id="start-flow" class="toolbar-btn">
                                    <span>â–¶ï¸</span> Start Flow
                                </button>
                                <button id="reset-partitions" class="toolbar-btn">
                                    <span>ðŸ”„</span> Reset
                                </button>
                            </div>
                        </div>

                        <div class="partitioning-workspace">
                            <!-- Top Row: Conveyor Belt Visualization -->
                            <div class="conveyor-row">
                                <div id="partitioning-conveyor" class="conveyor-container">
                                    <div class="conveyor-input">
                                        <h3>Input Data Stream</h3>
                                        <div id="data-source" class="data-source"></div>
                                    </div>
                                    
                                    <div class="conveyor-belt">
                                        <div id="conveyor-track" class="conveyor-track"></div>
                                        <div class="partitioning-logic">
                                            <div id="partitioner-box" class="partitioner-box">
                                                <span id="partitioner-label">Hash Function</span>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div class="partition-outputs">
                                        <h3>Partitions</h3>
                                        <div id="partition-bins" class="partition-bins"></div>
                                    </div>
                                </div>
                            </div>

                            <!-- Bottom Row: Controls and Info -->
                            <div class="controls-row">
                                <div class="controls-left">
                                    <div id="partition-controls" class="controls-panel">
                                        <h3>Partitioning Strategy</h3>
                                        <div class="strategy-selector">
                                            <select id="strategy-select">
                                                <option value="hash">Hash Partitioning</option>
                                                <option value="range">Range Partitioning</option>
                                                <option value="custom">Custom Partitioning</option>
                                            </select>
                                        </div>
                                        
                                        <div class="control-group">
                                            <label for="partition-count">Partition Count: <span id="partition-count-value">4</span></label>
                                            <input type="range" id="partition-count" min="2" max="16" value="4" step="1">
                                        </div>
                                        
                                        <div class="control-group">
                                            <label for="data-skew">Data Skew: <span id="data-skew-value">0%</span></label>
                                            <input type="range" id="data-skew" min="0" max="90" value="0" step="10">
                                        </div>
                                        
                                        <div class="control-group">
                                            <label for="animation-speed">Animation Speed: <span id="speed-value">1x</span></label>
                                            <input type="range" id="animation-speed" min="0.5" max="3" value="1" step="0.5">
                                        </div>
                                    </div>
                                    
                                    <div class="dataset-selector">
                                        <h3>Sample Dataset</h3>
                                        <select id="dataset-select">
                                            <option value="user-ids">User IDs</option>
                                            <option value="timestamps">Timestamps</option>
                                            <option value="skewed-data">Skewed Distribution</option>
                                        </select>
                                    </div>
                                </div>

                                <div class="controls-center">
                                    <div class="metrics-panel">
                                        <h3>Distribution Metrics</h3>
                                        <div id="partition-stats" class="partition-stats">
                                            <div class="stat-item">
                                                <span class="stat-label">Total Items:</span>
                                                <span id="total-items" class="stat-value">0</span>
                                            </div>
                                            <div class="stat-item">
                                                <span class="stat-label">Avg per Partition:</span>
                                                <span id="avg-per-partition" class="stat-value">0</span>
                                            </div>
                                            <div class="stat-item">
                                                <span class="stat-label">Load Balance:</span>
                                                <span id="load-balance" class="stat-value">Perfect</span>
                                            </div>
                                            <div class="stat-item">
                                                <span class="stat-label">Skew Factor:</span>
                                                <span id="skew-factor" class="stat-value">0%</span>
                                            </div>
                                        </div>
                                        
                                        <div class="partition-chart">
                                            <canvas id="distribution-chart" width="300" height="150"></canvas>
                                        </div>
                                    </div>
                                </div>

                                <div class="controls-right">
                                    <div class="info-panel">
                                        <h3>Strategy Details</h3>
                                        <div id="strategy-info" class="strategy-info">
                                            <div class="info-description"></div>
                                            <div class="info-properties"></div>
                                        </div>
                                    </div>
                                    
                                    <div id="challenge-panel" class="challenge-panel" style="display: none;">
                                        <h3>Challenge</h3>
                                        <div id="challenge-content"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
                this.attachStyles();
            }

            attachStyles() {
                if (document.getElementById('partitioning-styles')) return;
                
                const styles = document.createElement('style');
                styles.id = 'partitioning-styles';
                styles.textContent = `
                    .partitioning-container {
                        height: 100%;
                        display: flex;
                        flex-direction: column;
                        font-family: var(--font-sans);
                    }

                    .partitioning-toolbar {
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        padding: 1rem;
                        background: var(--bg-secondary);
                        border-bottom: 1px solid var(--border-default);
                    }

                    .partitioning-workspace {
                        flex: 1;
                        display: grid;
                        grid-template-rows: 400px 1fr !important;
                        gap: 1px;
                        background: var(--border-default);
                        min-height: 0;
                    }

                    .conveyor-row {
                        background: var(--bg-primary);
                        border: 1px solid var(--border-default);
                        margin: 0.5rem;
                        border-radius: 6px;
                        overflow: hidden;
                        padding: 1rem;
                    }

                    .conveyor-container {
                        height: 100%;
                        display: grid;
                        grid-template-columns: 200px 1fr 200px;
                        gap: 2rem;
                        align-items: center;
                    }

                    .conveyor-input, .partition-outputs {
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                    }

                    .data-source {
                        width: 150px;
                        height: 200px;
                        background: linear-gradient(135deg, var(--accent-subtle) 0%, var(--bg-secondary) 100%);
                        border: 2px solid var(--accent-emphasis);
                        border-radius: 8px;
                        position: relative;
                        overflow: hidden;
                    }

                    .conveyor-belt {
                        height: 100%;
                        display: flex;
                        flex-direction: column;
                        justify-content: center;
                        position: relative;
                    }

                    .conveyor-track {
                        height: 60px;
                        background: linear-gradient(90deg, #444 0%, #666 50%, #444 100%);
                        border: 2px solid var(--border-default);
                        border-radius: 8px;
                        position: relative;
                        overflow: hidden;
                    }

                    .partitioning-logic {
                        margin: 1rem 0;
                        display: flex;
                        justify-content: center;
                    }

                    .partitioner-box {
                        background: var(--accent-emphasis);
                        color: white;
                        padding: 1rem 2rem;
                        border-radius: 8px;
                        font-weight: 600;
                        box-shadow: var(--shadow-medium);
                    }

                    .partition-bins {
                        display: grid;
                        grid-template-columns: repeat(auto-fit, minmax(40px, 1fr));
                        gap: 0.5rem;
                        width: 150px;
                    }

                    .partition-bin {
                        height: 150px;
                        background: var(--bg-secondary);
                        border: 2px solid var(--border-default);
                        border-radius: 6px;
                        position: relative;
                        display: flex;
                        flex-direction: column;
                        cursor: pointer;
                        transition: all 0.2s ease;
                    }

                    .partition-bin:hover {
                        border-color: var(--accent-emphasis);
                        transform: translateY(-2px);
                    }

                    .partition-bin.selected {
                        border-color: var(--accent-emphasis);
                        background: var(--accent-subtle);
                    }

                    .partition-header {
                        background: var(--bg-accent);
                        padding: 0.25rem;
                        text-align: center;
                        font-size: 0.75rem;
                        font-weight: 500;
                        border-bottom: 1px solid var(--border-default);
                    }

                    .partition-content {
                        flex: 1;
                        padding: 0.25rem;
                        overflow: hidden;
                    }

                    .controls-row {
                        display: grid;
                        grid-template-columns: 300px 1fr 280px !important;
                        gap: 1px;
                        background: var(--border-default);
                    }

                    .controls-left, .controls-center, .controls-right {
                        background: var(--bg-primary);
                        padding: 1rem;
                        overflow-y: auto;
                    }

                    .controls-panel, .metrics-panel, .info-panel, .challenge-panel {
                        background: var(--bg-secondary);
                        border: 1px solid var(--border-default);
                        border-radius: 6px;
                        padding: 1rem;
                        margin-bottom: 1rem;
                    }

                    .controls-panel h3, .metrics-panel h3, .info-panel h3, .challenge-panel h3 {
                        margin: 0 0 1rem 0;
                        font-size: 1rem;
                        font-weight: 600;
                        color: var(--text-primary);
                    }

                    .control-group {
                        margin-bottom: 1rem;
                    }

                    .control-group label {
                        display: block;
                        margin-bottom: 0.5rem;
                        font-size: 0.875rem;
                        font-weight: 500;
                        color: var(--text-primary);
                    }

                    .control-group input[type="range"] {
                        width: 100%;
                        margin-bottom: 0.5rem;
                    }

                    .control-group select {
                        width: 100%;
                        padding: 0.5rem;
                        border: 1px solid var(--border-default);
                        border-radius: 4px;
                        background: var(--bg-primary);
                        color: var(--text-primary);
                    }

                    .partition-stats {
                        margin-bottom: 1rem;
                    }

                    .stat-item {
                        display: flex;
                        justify-content: space-between;
                        padding: 0.25rem 0;
                        border-bottom: 1px solid var(--border-muted);
                    }

                    .stat-item:last-child {
                        border-bottom: none;
                    }

                    .stat-label {
                        font-weight: 500;
                        color: var(--text-primary);
                    }

                    .stat-value {
                        color: var(--text-secondary);
                        font-family: var(--font-mono);
                    }

                    .data-item {
                        width: 20px;
                        height: 20px;
                        background: var(--accent-emphasis);
                        border-radius: 4px;
                        margin: 2px;
                        display: inline-block;
                        position: relative;
                        transition: all 0.3s ease;
                    }

                    .data-item.moving {
                        animation: moveOnBelt 2s linear;
                    }

                    @keyframes moveOnBelt {
                        0% { transform: translateX(-100px); }
                        50% { transform: translateX(0px); }
                        100% { transform: translateX(100px); }
                    }

                    .route-tab {
                        padding: 0.5rem 1rem;
                        border: 1px solid var(--border-default);
                        background: var(--bg-primary);
                        color: var(--text-secondary);
                        cursor: pointer;
                        border-radius: 4px;
                        font-size: 0.875rem;
                        transition: all 0.2s ease;
                        margin-right: 0.5rem;
                    }

                    .route-tab:hover {
                        background: var(--bg-accent);
                        color: var(--text-primary);
                    }

                    .route-tab.active {
                        background: var(--accent-emphasis);
                        color: white;
                        border-color: var(--accent-emphasis);
                    }

                    .toolbar-btn {
                        padding: 0.5rem 0.75rem;
                        border: 1px solid var(--border-default);
                        background: var(--bg-primary);
                        color: var(--text-secondary);
                        cursor: pointer;
                        border-radius: 4px;
                        font-size: 0.875rem;
                        display: flex;
                        align-items: center;
                        gap: 0.25rem;
                        transition: all 0.2s ease;
                        margin-left: 0.5rem;
                    }

                    .toolbar-btn:hover {
                        background: var(--bg-accent);
                        color: var(--text-primary);
                        border-color: var(--accent-emphasis);
                    }
                    
                    .partition-chart {
                        margin-top: 1rem;
                    }
                    
                    .partition-chart canvas {
                        border: 1px solid var(--border-default);
                        border-radius: 4px;
                        background: var(--bg-primary);
                    }
                    
                    .challenge-btn {
                        width: 100%;
                        padding: 1rem;
                        margin-bottom: 0.5rem;
                        border: 1px solid var(--border-default);
                        background: var(--bg-secondary);
                        color: var(--text-primary);
                        cursor: pointer;
                        border-radius: 6px;
                        text-align: left;
                        transition: all 0.2s ease;
                    }
                    
                    .challenge-btn:hover {
                        background: var(--bg-accent);
                        border-color: var(--accent-emphasis);
                    }
                    
                    .challenge-title {
                        font-weight: 500;
                        margin-bottom: 0.25rem;
                    }
                    
                    .challenge-desc {
                        font-size: 0.875rem;
                        color: var(--text-secondary);
                        margin-bottom: 0.25rem;
                    }
                    
                    .challenge-goal {
                        font-size: 0.75rem;
                        color: var(--accent-emphasis);
                        font-weight: 500;
                    }
                    
                    .challenge-status {
                        padding: 0.75rem;
                        border-radius: 4px;
                        margin: 1rem 0;
                        text-align: center;
                        font-weight: 500;
                    }
                    
                    .challenge-status.complete {
                        background: var(--success-emphasis);
                        color: white;
                    }
                    
                    .challenge-status.incomplete {
                        background: var(--attention-emphasis);
                        color: white;
                    }
                    
                    .challenge-hint {
                        padding: 0.75rem;
                        background: var(--accent-subtle);
                        border-radius: 4px;
                        margin: 1rem 0;
                        font-size: 0.875rem;
                        border-left: 3px solid var(--accent-emphasis);
                    }
                    
                    .challenge-actions {
                        display: flex;
                        gap: 0.5rem;
                        margin-top: 1rem;
                    }
                    
                    .check-btn, .exit-btn {
                        flex: 1;
                        padding: 0.75rem;
                        border: 1px solid var(--border-default);
                        border-radius: 4px;
                        cursor: pointer;
                        font-size: 0.875rem;
                        transition: all 0.2s ease;
                    }
                    
                    .check-btn {
                        background: var(--accent-emphasis);
                        color: white;
                        border-color: var(--accent-emphasis);
                    }
                    
                    .check-btn:hover {
                        background: var(--accent-fg);
                    }
                    
                    .exit-btn {
                        background: var(--bg-primary);
                        color: var(--text-secondary);
                    }
                    
                    .exit-btn:hover {
                        background: var(--bg-accent);
                        color: var(--text-primary);
                    }
                    
                    .property-item {
                        display: flex;
                        justify-content: space-between;
                        padding: 0.25rem 0;
                        border-bottom: 1px solid var(--border-muted);
                    }
                    
                    .property-item:last-child {
                        border-bottom: none;
                    }
                    
                    .property-label {
                        font-weight: 500;
                        color: var(--text-primary);
                    }
                    
                    .property-value {
                        color: var(--text-secondary);
                        font-family: var(--font-mono);
                    }
                `;
                
                document.head.appendChild(styles);
            }

            setupEventListeners() {
                // Route switching
                this.element.querySelectorAll('.route-tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        const route = e.target.dataset.route;
                        this.switchRoute(route);
                    });
                });

                // Controls
                this.element.querySelector('#partition-count').addEventListener('input', (e) => {
                    this.partitionCount = parseInt(e.target.value);
                    this.element.querySelector('#partition-count-value').textContent = this.partitionCount;
                    this.updatePartitions();
                });

                this.element.querySelector('#strategy-select').addEventListener('change', (e) => {
                    this.currentStrategy = e.target.value;
                    this.updateStrategy();
                });

                this.element.querySelector('#data-skew').addEventListener('input', (e) => {
                    this.dataSkew = parseInt(e.target.value);
                    this.element.querySelector('#data-skew-value').textContent = this.dataSkew + '%';
                    this.regenerateData();
                });

                this.element.querySelector('#animation-speed').addEventListener('input', (e) => {
                    this.animationSpeed = 1000 / parseFloat(e.target.value);
                    this.element.querySelector('#speed-value').textContent = e.target.value + 'x';
                });

                this.element.querySelector('#dataset-select').addEventListener('change', (e) => {
                    this.loadDataset(e.target.value);
                });

                // Toolbar buttons
                this.element.querySelector('#start-flow').addEventListener('click', () => {
                    this.startDataFlow();
                });

                this.element.querySelector('#reset-partitions').addEventListener('click', () => {
                    this.resetPartitions();
                });
            }

            initializeData() {
                this.loadDataset('user-ids');
                this.updatePartitions();
                this.updateStrategy();
            }

            // Placeholder methods - will implement these next
            hashPartition(item) { 
                // Simple hash function - more realistic would use better distribution
                const hash = this.simpleHash(item.value.toString());
                return Math.abs(hash) % this.partitionCount; 
            }
            
            rangePartition(item) { 
                // Range partitioning based on value ranges
                if (item.type === 'timestamp') {
                    // For timestamps, use time-based ranges
                    const timeRange = item.value % (24 * 60 * 60 * 1000); // Daily ranges
                    return Math.floor((timeRange / (24 * 60 * 60 * 1000)) * this.partitionCount);
                }
                // For numeric values, use value-based ranges
                const maxValue = 100;
                const rangeSize = maxValue / this.partitionCount;
                return Math.min(Math.floor(item.value / rangeSize), this.partitionCount - 1);
            }
            
            customPartition(item) { 
                // Custom partitioning - could be user-defined
                if (item.type === 'user') {
                    // Partition users by ID pattern
                    return item.value % this.partitionCount;
                } else if (item.type === 'skewed') {
                    // For skewed data, try to balance better
                    return (item.value * 7 + 13) % this.partitionCount;
                }
                return item.value % this.partitionCount; 
            }

            simpleHash(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32-bit integer
                }
                return hash;
            }
            generateSkewedData(count) {
                const data = [];
                for (let i = 0; i < count; i++) {
                    // Create heavily skewed data - 80% of data in first 20% of range
                    const skewThreshold = 0.8;
                    const value = Math.random() < skewThreshold 
                        ? Math.floor(Math.random() * 20)  // 80% in 0-19
                        : Math.floor(Math.random() * 80) + 20; // 20% in 20-99
                    
                    data.push({
                        id: `skewed_${i}`,
                        value: value,
                        type: 'skewed'
                    });
                }
                return data;
            }

            validateLoadBalance() {
                const partitionSizes = this.partitions.map(p => p.length);
                const avg = partitionSizes.reduce((a, b) => a + b, 0) / partitionSizes.length;
                const variance = partitionSizes.map(size => Math.abs(size - avg) / avg * 100);
                const maxVariance = Math.max(...variance);
                return maxVariance < 20;
            }

            validateHashPrediction() {
                // Check if user correctly predicted hash assignments for test items
                return this.predictionScore >= 8;
            }

            validateRangeDesign() {
                // Check if range boundaries enable efficient queries
                return this.rangeEfficiencyScore >= 80;
            }

            loadDataset(dataset) {
                const datasetConfig = this.sampleDatasets[dataset];
                if (!datasetConfig) return;
                
                this.dataItems = [...datasetConfig.data];
                this.redistributeData();
                this.updateStats();
                this.renderDataSource();
            }

            updatePartitions() {
                this.partitions = Array.from({length: this.partitionCount}, () => []);
                this.redistributeData();
                this.renderPartitionBins();
                this.updateStats();
            }

            updateStrategy() {
                const strategy = this.partitioningStrategies[this.currentStrategy];
                const partitionerLabel = this.element.querySelector('#partitioner-label');
                const strategyInfo = this.element.querySelector('#strategy-info');
                
                if (partitionerLabel) {
                    partitionerLabel.textContent = strategy.name;
                    this.element.querySelector('#partitioner-box').style.backgroundColor = strategy.color;
                }
                
                if (strategyInfo) {
                    strategyInfo.innerHTML = `
                        <div class="info-description">${strategy.description}</div>
                        <div class="info-properties">
                            <div class="property-item">
                                <span class="property-label">Type:</span>
                                <span class="property-value">${this.currentStrategy.charAt(0).toUpperCase() + this.currentStrategy.slice(1)}</span>
                            </div>
                            <div class="property-item">
                                <span class="property-label">Deterministic:</span>
                                <span class="property-value">${this.currentStrategy === 'hash' ? 'Yes' : 'Configurable'}</span>
                            </div>
                            <div class="property-item">
                                <span class="property-label">Load Balance:</span>
                                <span class="property-value">${this.currentStrategy === 'hash' ? 'Good' : 'Variable'}</span>
                            </div>
                        </div>
                    `;
                }
                
                this.redistributeData();
                this.updateStats();
            }

            regenerateData() {
                const currentDataset = document.getElementById('dataset-select').value;
                if (currentDataset === 'skewed-data') {
                    this.sampleDatasets['skewed-data'].data = this.generateSkewedData(100);
                    this.loadDataset('skewed-data');
                }
            }

            redistributeData() {
                // Clear all partitions
                this.partitions = Array.from({length: this.partitionCount}, () => []);
                
                // Distribute data items based on current strategy
                this.dataItems.forEach(item => {
                    const strategy = this.partitioningStrategies[this.currentStrategy];
                    const partitionIndex = strategy.partition(item);
                    const clampedIndex = Math.max(0, Math.min(partitionIndex, this.partitionCount - 1));
                    this.partitions[clampedIndex].push(item);
                });
                
                this.renderPartitionBins();
                this.updateDistributionChart();
            }

            renderDataSource() {
                const container = this.element.querySelector('#data-source');
                if (!container) return;
                
                container.innerHTML = '';
                const sampleItems = this.dataItems.slice(0, 20); // Show first 20 items
                
                sampleItems.forEach(item => {
                    const itemEl = document.createElement('div');
                    itemEl.className = 'data-item';
                    itemEl.title = `${item.id}: ${item.value}`;
                    container.appendChild(itemEl);
                });
                
                if (this.dataItems.length > 20) {
                    const moreEl = document.createElement('div');
                    moreEl.className = 'data-item';
                    moreEl.style.background = 'var(--text-muted)';
                    moreEl.title = `... and ${this.dataItems.length - 20} more items`;
                    container.appendChild(moreEl);
                }
            }

            renderPartitionBins() {
                const container = this.element.querySelector('#partition-bins');
                if (!container) return;
                
                container.innerHTML = '';
                
                for (let i = 0; i < this.partitionCount; i++) {
                    const bin = document.createElement('div');
                    bin.className = 'partition-bin';
                    bin.dataset.partitionId = i;
                    
                    if (this.selectedPartition === i) {
                        bin.classList.add('selected');
                    }
                    
                    bin.innerHTML = `
                        <div class="partition-header">P${i}</div>
                        <div class="partition-content" id="partition-${i}"></div>
                    `;
                    
                    bin.addEventListener('click', () => {
                        this.selectedPartition = this.selectedPartition === i ? null : i;
                        this.renderPartitionBins();
                        this.highlightPartitionData(i);
                    });
                    
                    container.appendChild(bin);
                    
                    // Render items in partition
                    const content = this.element.querySelector(`#partition-${i}`);
                    const partitionData = this.partitions[i] || [];
                    const maxVisible = 20;
                    
                    partitionData.slice(0, maxVisible).forEach(item => {
                        const itemEl = document.createElement('div');
                        itemEl.className = 'data-item';
                        itemEl.style.width = '8px';
                        itemEl.style.height = '8px';
                        itemEl.title = `${item.id}: ${item.value}`;
                        content.appendChild(itemEl);
                    });
                    
                    if (partitionData.length > maxVisible) {
                        const moreEl = document.createElement('div');
                        moreEl.style.fontSize = '0.6rem';
                        moreEl.style.color = 'var(--text-muted)';
                        moreEl.style.textAlign = 'center';
                        moreEl.textContent = `+${partitionData.length - maxVisible}`;
                        content.appendChild(moreEl);
                    }
                }
            }

            updateStats() {
                const totalItems = this.dataItems.length;
                const avgPerPartition = Math.round(totalItems / this.partitionCount);
                
                // Calculate load balance
                const partitionSizes = this.partitions.map(p => p.length);
                const maxSize = Math.max(...partitionSizes);
                const minSize = Math.min(...partitionSizes);
                const variance = maxSize > 0 ? ((maxSize - minSize) / maxSize * 100) : 0;
                
                let balanceText = 'Perfect';
                if (variance > 30) balanceText = 'Poor';
                else if (variance > 15) balanceText = 'Fair';
                else if (variance > 5) balanceText = 'Good';
                
                // Update DOM
                this.element.querySelector('#total-items').textContent = totalItems;
                this.element.querySelector('#avg-per-partition').textContent = avgPerPartition;
                this.element.querySelector('#load-balance').textContent = balanceText;
                this.element.querySelector('#skew-factor').textContent = Math.round(variance) + '%';
            }

            updateDistributionChart() {
                const canvas = this.element.querySelector('#distribution-chart');
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                // Draw chart
                const partitionSizes = this.partitions.map(p => p.length);
                const maxSize = Math.max(...partitionSizes, 1);
                const barWidth = width / this.partitionCount;
                
                partitionSizes.forEach((size, i) => {
                    const barHeight = (size / maxSize) * (height - 40);
                    const x = i * barWidth;
                    const y = height - barHeight - 20;
                    
                    // Bar
                    ctx.fillStyle = this.selectedPartition === i ? '#0969da' : '#6e7781';
                    ctx.fillRect(x + 2, y, barWidth - 4, barHeight);
                    
                    // Label
                    ctx.fillStyle = '#24292f';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`P${i}`, x + barWidth/2, height - 5);
                    ctx.fillText(size.toString(), x + barWidth/2, y - 5);
                });
            }

            highlightPartitionData(partitionIndex) {
                // Visual feedback for selected partition
                this.api.announceToScreenReader(`Selected partition ${partitionIndex} with ${this.partitions[partitionIndex].length} items`);
            }

            startDataFlow() {
                if (this.isAnimating) return;
                
                this.isAnimating = true;
                const items = this.dataItems.slice(0, 10); // Animate first 10 items
                
                items.forEach((item, index) => {
                    setTimeout(() => {
                        this.animateItemFlow(item);
                    }, index * (this.animationSpeed / 10));
                });
                
                setTimeout(() => {
                    this.isAnimating = false;
                }, items.length * (this.animationSpeed / 10) + 1000);
            }

            animateItemFlow(item) {
                const track = this.element.querySelector('#conveyor-track');
                if (!track) return;
                
                const itemEl = document.createElement('div');
                itemEl.className = 'data-item moving';
                itemEl.style.position = 'absolute';
                itemEl.style.top = '20px';
                itemEl.style.left = '0px';
                itemEl.title = `${item.id}: ${item.value}`;
                
                track.appendChild(itemEl);
                
                // Remove after animation
                setTimeout(() => {
                    if (itemEl.parentNode) {
                        itemEl.parentNode.removeChild(itemEl);
                    }
                }, 2000);
            }

            resetPartitions() {
                this.partitions = Array.from({length: this.partitionCount}, () => []);
                this.selectedPartition = null;
                this.renderPartitionBins();
                this.updateStats();
                this.updateDistributionChart();
                this.api.announceToScreenReader('Partitions reset');
            }

            switchRoute(route) {
                // Update active tab
                this.element.querySelectorAll('.route-tab').forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.route === route);
                });
                
                // Show/hide challenge panel
                const challengePanel = this.element.querySelector('#challenge-panel');
                if (route === 'challenges') {
                    challengePanel.style.display = 'block';
                    this.showChallenges();
                } else {
                    challengePanel.style.display = 'none';
                }
                
                // Update strategy based on route
                if (route === 'hash') {
                    this.currentStrategy = 'hash';
                    this.element.querySelector('#strategy-select').value = 'hash';
                    this.updateStrategy();
                } else if (route === 'range') {
                    this.currentStrategy = 'range';
                    this.element.querySelector('#strategy-select').value = 'range';
                    this.updateStrategy();
                } else if (route === 'custom') {
                    this.currentStrategy = 'custom';
                    this.element.querySelector('#strategy-select').value = 'custom';
                    this.updateStrategy();
                }
                
                this.api.navigateToRoute(route);
            }

            showChallenges() {
                const content = this.element.querySelector('#challenge-content');
                if (!content) return;
                
                if (!this.currentChallenge) {
                    content.innerHTML = `
                        <div class="challenge-list">
                            <h4>Partitioning Challenges</h4>
                            <p>Test your partitioning strategies:</p>
                            ${this.challenges.map(challenge => `
                                <button class="challenge-btn" data-id="${challenge.id}">
                                    <div class="challenge-title">${challenge.title}</div>
                                    <div class="challenge-desc">${challenge.description}</div>
                                    <div class="challenge-goal">${challenge.goal}</div>
                                </button>
                            `).join('')}
                        </div>
                    `;
                    
                    // Bind challenge button handlers
                    this.element.querySelectorAll('.challenge-btn').forEach(btn => {
                        btn.addEventListener('click', () => {
                            this.startChallenge(btn.dataset.id);
                        });
                    });
                } else {
                    this.renderCurrentChallenge();
                }
            }

            startChallenge(challengeId) {
                this.currentChallenge = this.challenges.find(c => c.id === challengeId);
                if (this.currentChallenge) {
                    this.loadDataset(this.currentChallenge.dataset);
                    this.renderCurrentChallenge();
                    this.api.announceToScreenReader(`Started challenge: ${this.currentChallenge.title}`);
                }
            }

            renderCurrentChallenge() {
                const content = this.element.querySelector('#challenge-content');
                const isComplete = this.currentChallenge.validator();
                
                content.innerHTML = `
                    <div class="challenge-active">
                        <h4>${this.currentChallenge.title}</h4>
                        <p class="challenge-description">${this.currentChallenge.description}</p>
                        <p class="challenge-goal"><strong>Goal:</strong> ${this.currentChallenge.goal}</p>
                        
                        <div class="challenge-status ${isComplete ? 'complete' : 'incomplete'}">
                            <div class="status-indicator">
                                ${isComplete ? 'âœ…' : 'â³'}
                                ${isComplete ? 'Challenge Complete!' : 'In Progress'}
                            </div>
                        </div>
                        
                        ${!isComplete ? `
                            <div class="challenge-hint">
                                <strong>Hint:</strong> ${this.currentChallenge.hint}
                            </div>
                        ` : ''}
                        
                        <div class="challenge-actions">
                            <button id="check-challenge-btn" class="check-btn">
                                Check Solution
                            </button>
                            <button id="exit-challenge-btn" class="exit-btn">
                                Exit Challenge
                            </button>
                        </div>
                    </div>
                `;
                
                // Bind challenge action handlers
                this.element.querySelector('#check-challenge-btn').addEventListener('click', () => {
                    this.checkChallenge();
                });
                this.element.querySelector('#exit-challenge-btn').addEventListener('click', () => {
                    this.exitChallenge();
                });
            }

            checkChallenge() {
                if (this.currentChallenge) {
                    const isComplete = this.currentChallenge.validator();
                    this.renderCurrentChallenge();
                    
                    if (isComplete) {
                        this.api.announceToScreenReader('Challenge completed successfully!');
                    } else {
                        this.api.announceToScreenReader('Challenge not yet complete. Keep adjusting your strategy!');
                    }
                }
            }

            exitChallenge() {
                this.currentChallenge = null;
                this.showChallenges();
                this.api.announceToScreenReader('Exited challenge mode');
            }
        }

        window.partitioningModule = null;

        class LineageStagesShufflesModule {
            constructor(element, api) {
                this.element = element;
                this.api = api;
                this.currentRoute = 'lineage-flow';
                this.operations = [];
                this.partitionCount = 4;
                this.dataSkew = 0;
                this.isAnimating = false;
                this.challenges = new Map();
                
                this.setupOperationTemplates();
                this.setupChallenges();
            }

            setupOperationTemplates() {
                this.operationTemplates = {
                    // Narrow transformations
                    'map': {
                        name: 'map',
                        type: 'narrow',
                        description: 'Transform each element',
                        color: '#1a7f37',
                        preservesPartitioning: true
                    },
                    'filter': {
                        name: 'filter',
                        type: 'narrow',
                        description: 'Keep elements matching predicate',
                        color: '#1a7f37',
                        preservesPartitioning: true
                    },
                    'sample': {
                        name: 'sample',
                        type: 'narrow',
                        description: 'Random sample of elements',
                        color: '#1a7f37',
                        preservesPartitioning: true
                    },
                    'flatMap': {
                        name: 'flatMap',
                        type: 'narrow',
                        description: 'Transform and flatten',
                        color: '#1a7f37',
                        preservesPartitioning: true
                    },
                    
                    // Wide transformations
                    'groupBy': {
                        name: 'groupBy',
                        type: 'wide',
                        description: 'Group by key (shuffle)',
                        color: '#9a6700',
                        triggersStage: true,
                        shuffleType: 'hash'
                    },
                    'join': {
                        name: 'join',
                        type: 'wide',
                        description: 'Join two datasets',
                        color: '#9a6700',
                        triggersStage: true,
                        shuffleType: 'hash'
                    },
                    'distinct': {
                        name: 'distinct',
                        type: 'wide',
                        description: 'Remove duplicates',
                        color: '#9a6700',
                        triggersStage: true,
                        shuffleType: 'hash'
                    },
                    'sortBy': {
                        name: 'sortBy',
                        type: 'wide',
                        description: 'Sort by key',
                        color: '#9a6700',
                        triggersStage: true,
                        shuffleType: 'range'
                    }
                };
            }

            setupChallenges() {
                this.challenges.set('classify-narrow-wide', {
                    title: 'Classify Narrow vs Wide',
                    description: 'Add at least one narrow and one wide operation',
                    validator: () => {
                        const hasNarrow = this.operations.some(op => this.operationTemplates[op].type === 'narrow');
                        const hasWide = this.operations.some(op => this.operationTemplates[op].type === 'wide');
                        return hasNarrow && hasWide;
                    }
                });

                this.challenges.set('create-stages', {
                    title: 'Create Multiple Stages',
                    description: 'Insert a wide operation to produce â‰¥2 stages',
                    validator: () => {
                        return this.computeStageCount() >= 2;
                    }
                });

                this.challenges.set('hotspot-detection', {
                    title: 'Hotspot Detection',
                    description: 'With skew preset, show one partition becoming hotspot',
                    validator: () => {
                        return this.dataSkew > 50 && this.hasHotspotPartition();
                    }
                });
            }

            init() {
                this.render();
                this.setupEventListeners();
                this.renderOperationPalette();
                this.updateVisualization();
                this.updateMetrics();
                this.updateChallenges();
                this.api.announceToScreenReader('Lineage, Stages & Shuffles module loaded');
            }

            render() {
                this.element.innerHTML = `
                    <div class="lineage-stages-container">
                        <div class="explanation-panel" id="explanationPanel">
                            <div class="explanation-content">
                                <div class="explanation-header">
                                    <div class="explanation-icon">ðŸŽ“</div>
                                    <div class="explanation-title">What You'll Learn: Lineage, Stages & Shuffles</div>
                                    <button class="close-btn" id="closeExplanation">Ã—</button>
                                </div>
                                <div class="explanation-text">
                                    <strong>Understanding Spark's execution model:</strong>
                                    <span class="narrow-ops">ðŸŸ¢ Narrow operations</span> (map, filter) keep data in same partitions - fast & local.
                                    <span class="wide-ops">ðŸŸ¡ Wide operations</span> (groupBy, join) shuffle data across partitions - slow & network-intensive.
                                    <span class="stage-boundaries">ðŸ”´ Stage boundaries</span> form where shuffles happen, breaking your job into stages.
                                    <strong>ðŸ’¡ Key insight:</strong> Minimize wide operations and data skew for better performance!
                                </div>
                            </div>
                        </div>

                        <div class="lineage-toolbar">
                            <div class="toolbar-left">
                                <h1>Lineage, Stages & Shuffles</h1>
                                <div class="route-tabs" id="routeTabs">
                                    <button class="route-tab active" data-route="lineage-flow">Lineage Flow</button>
                                    <button class="route-tab" data-route="stage-boundaries">Stage Boundaries</button>
                                    <button class="route-tab" data-route="shuffle-anatomy">Shuffle Anatomy</button>
                                </div>
                            </div>
                            <div class="toolbar-controls">
                                <button class="control-btn" id="resetBtn">ðŸ”„ Reset</button>
                                <button class="control-btn" id="playBtn">â–¶ï¸ Animate</button>
                            </div>
                        </div>

                        <div class="lineage-workspace">
                            <div class="main-visualization">
                                <div class="river-canvas" id="riverCanvas">
                                    <!-- River visualization will be dynamically generated here -->
                                </div>
                            </div>

                            <div class="controls-panel">
                                <div class="control-section">
                                    <h3>Operation Palette</h3>
                                    <div class="operation-palette" id="operationPalette">
                                        <!-- Operation buttons will be generated here -->
                                    </div>
                                    
                                    <div class="operation-chain" id="operationChain">
                                        <!-- Current operation chain will be shown here -->
                                    </div>
                                </div>

                                <div class="control-section">
                                    <h3>Configuration</h3>
                                    
                                    <div class="slider-control">
                                        <label for="partitionCount">Partition Count: <span class="slider-value" id="partitionCountValue">4</span></label>
                                        <input type="range" id="partitionCount" min="2" max="16" value="4" step="1">
                                    </div>

                                    <div class="slider-control">
                                        <label for="dataSkew">Data Skew: <span class="slider-value" id="dataSkewValue">0%</span></label>
                                        <input type="range" id="dataSkew" min="0" max="90" value="0" step="10">
                                    </div>

                                    <div class="preset-buttons">
                                        <button class="preset-btn" data-preset="balanced">Balanced</button>
                                        <button class="preset-btn" data-preset="skewed">Skewed</button>
                                        <button class="preset-btn" data-preset="extreme">Extreme Skew</button>
                                        <button class="preset-btn" data-preset="custom">Custom</button>
                                    </div>
                                </div>

                                <div class="control-section">
                                    <h3>Metrics & Challenges</h3>
                                    
                                    <div class="metrics-grid" id="metricsGrid">
                                        <!-- Metrics will be populated here -->
                                    </div>

                                    <div class="challenge-panel" id="challengePanel">
                                        <!-- Current challenge will be shown here -->
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <style>
                        .lineage-stages-container {
                            height: 100%;
                            display: flex;
                            flex-direction: column;
                            font-family: var(--font-sans);
                        }

                        .explanation-panel {
                            background: linear-gradient(135deg, var(--accent-subtle), var(--bg-secondary));
                            border-bottom: 2px solid var(--accent-emphasis);
                            padding: 12px 16px;
                            flex-shrink: 0;
                            animation: slideDown 0.3s ease-out;
                        }

                        .explanation-panel.hidden {
                            display: none;
                        }

                        .explanation-content {
                            max-width: 1000px;
                            margin: 0 auto;
                        }

                        .explanation-header {
                            display: flex;
                            align-items: center;
                            margin-bottom: 8px;
                        }

                        .explanation-icon {
                            font-size: 20px;
                            margin-right: 10px;
                        }

                        .explanation-title {
                            font-size: 16px;
                            font-weight: bold;
                            color: var(--accent-fg);
                            flex: 1;
                        }

                        .close-btn {
                            background: none;
                            border: none;
                            font-size: 20px;
                            color: var(--text-muted);
                            cursor: pointer;
                            padding: 0;
                            width: 24px;
                            height: 24px;
                            border-radius: 50%;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            transition: all 0.2s ease;
                        }

                        .close-btn:hover {
                            background: var(--bg-accent);
                            color: var(--text-primary);
                        }

                        .explanation-text {
                            font-size: 13px;
                            line-height: 1.4;
                            color: var(--text-primary);
                        }

                        .narrow-ops {
                            color: var(--success-emphasis);
                            font-weight: 600;
                        }

                        .wide-ops {
                            color: var(--attention-emphasis);
                            font-weight: 600;
                        }

                        .stage-boundaries {
                            color: var(--danger-emphasis);
                            font-weight: 600;
                        }

                        @keyframes slideDown {
                            0% {
                                transform: translateY(-100%);
                                opacity: 0;
                            }
                            100% {
                                transform: translateY(0);
                                opacity: 1;
                            }
                        }

                        .lineage-toolbar {
                            background: var(--bg-secondary);
                            border-bottom: 1px solid var(--border-default);
                            padding: 1rem;
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                            flex-shrink: 0;
                        }

                        .lineage-toolbar h1 {
                            font-size: 1.25rem;
                            font-weight: 600;
                            margin-bottom: 0.5rem;
                        }

                        .route-tabs {
                            display: flex;
                            gap: 0.5rem;
                        }

                        .route-tab {
                            padding: 0.5rem 1rem;
                            border: 1px solid var(--border-default);
                            background: var(--bg-primary);
                            color: var(--text-secondary);
                            cursor: pointer;
                            border-radius: 4px;
                            font-size: 0.875rem;
                            transition: all 0.2s ease;
                        }

                        .route-tab:hover {
                            background: var(--bg-accent);
                            color: var(--text-primary);
                        }

                        .route-tab.active {
                            background: var(--accent-emphasis);
                            color: white;
                            border-color: var(--accent-emphasis);
                        }

                        .toolbar-controls {
                            display: flex;
                            gap: 0.5rem;
                            align-items: center;
                        }

                        .control-btn {
                            padding: 0.5rem 0.75rem;
                            border: 1px solid var(--border-default);
                            background: var(--bg-primary);
                            color: var(--text-secondary);
                            cursor: pointer;
                            border-radius: 4px;
                            font-size: 0.875rem;
                            transition: all 0.2s ease;
                        }

                        .control-btn:hover {
                            background: var(--bg-accent);
                            color: var(--text-primary);
                            border-color: var(--accent-emphasis);
                        }

                        .lineage-workspace {
                            flex: 1;
                            display: grid;
                            grid-template-rows: 1fr 200px;
                            gap: 1px;
                            background: var(--border-default);
                            min-height: 0;
                        }

                        .main-visualization {
                            background: var(--bg-primary);
                            padding: 1rem;
                            overflow: hidden;
                            position: relative;
                            min-height: 450px;
                        }

                        .controls-panel {
                            background: var(--bg-secondary);
                            padding: 1rem;
                            display: grid;
                            grid-template-columns: 300px 1fr 300px;
                            gap: 1rem;
                            overflow-y: auto;
                        }

                        .control-section {
                            background: var(--bg-accent);
                            border: 1px solid var(--border-default);
                            border-radius: 6px;
                            padding: 1rem;
                        }

                        .control-section h3 {
                            font-size: 1rem;
                            font-weight: 600;
                            margin-bottom: 1rem;
                            color: var(--text-primary);
                        }

                        .operation-palette {
                            display: grid;
                            grid-template-columns: 1fr 1fr;
                            gap: 0.5rem;
                            margin-bottom: 1rem;
                        }

                        .op-btn {
                            padding: 0.75rem;
                            border: 1px solid var(--border-default);
                            background: var(--bg-secondary);
                            color: var(--text-primary);
                            cursor: pointer;
                            border-radius: 4px;
                            font-size: 0.875rem;
                            text-align: center;
                            transition: all 0.2s ease;
                            position: relative;
                        }

                        .op-btn:hover {
                            background: var(--bg-accent);
                            border-color: var(--accent-emphasis);
                            transform: translateY(-1px);
                        }

                        .op-btn.narrow {
                            border-left: 3px solid var(--success-emphasis);
                        }

                        .op-btn.wide {
                            border-left: 3px solid var(--attention-emphasis);
                        }

                        .river-canvas {
                            width: 100%;
                            height: 100%;
                            background: linear-gradient(to bottom, #e3f2fd 0%, #bbdefb 100%);
                            border: 1px solid var(--border-default);
                            border-radius: 8px;
                            position: relative;
                            overflow: hidden;
                            min-height: 400px;
                        }

                        .partition-stream {
                            position: absolute;
                            background: var(--river-blue);
                            border-radius: 4px;
                            transition: all 0.3s ease;
                            opacity: 0.8;
                            overflow: hidden;
                        }

                        .flow-particle {
                            position: absolute;
                            background: rgba(255, 255, 255, 0.6);
                            border-radius: 50%;
                            width: 6px;
                            height: 6px;
                            animation: flowDown 3s linear infinite;
                        }

                        @keyframes flowDown {
                            0% { transform: translateY(-10px); opacity: 0; }
                            10% { opacity: 1; }
                            90% { opacity: 1; }
                            100% { transform: translateY(420px); opacity: 0; }
                        }

                        @keyframes streamPulse {
                            0%, 100% { 
                                transform: scaleX(1);
                                filter: brightness(1);
                            }
                            50% { 
                                transform: scaleX(1.1);
                                filter: brightness(1.2);
                            }
                        }

                        @keyframes shuffleEffect {
                            0%, 100% { 
                                transform: scaleX(1) translateX(0);
                                filter: hue-rotate(0deg);
                            }
                            25% { 
                                transform: scaleX(0.8) translateX(-2px);
                                filter: hue-rotate(90deg);
                            }
                            50% { 
                                transform: scaleX(1.2) translateX(0);
                                filter: hue-rotate(180deg);
                            }
                            75% { 
                                transform: scaleX(0.8) translateX(2px);
                                filter: hue-rotate(270deg);
                            }
                        }

                        @keyframes narrowFlow {
                            0%, 100% { 
                                transform: scaleY(1);
                                filter: brightness(1);
                            }
                            50% { 
                                transform: scaleY(1.05);
                                filter: brightness(1.1);
                            }
                        }

                        @keyframes stepAppear {
                            0% { 
                                transform: translateX(-50px);
                                opacity: 0;
                            }
                            100% { 
                                transform: translateX(0);
                                opacity: 1;
                            }
                        }

                        @keyframes stageBoundaryAppear {
                            0% { 
                                width: 0;
                                opacity: 0;
                            }
                            50% {
                                opacity: 1;
                            }
                            100% { 
                                width: calc(100% - 120px);
                                opacity: 1;
                            }
                        }

                        @keyframes partitionUpdate {
                            0% { 
                                transform: scale(0.8);
                                opacity: 0;
                            }
                            50% {
                                transform: scale(1.1);
                            }
                            100% { 
                                transform: scale(1);
                                opacity: 1;
                            }
                        }

                        @keyframes hotspotAlert {
                            0%, 100% { 
                                transform: scale(1);
                                opacity: 0.9;
                            }
                            50% { 
                                transform: scale(1.3);
                                opacity: 1;
                            }
                        }

                        .stage-dam {
                            position: absolute;
                            background: #8d6e63;
                            border-radius: 4px;
                            box-shadow: var(--shadow-medium);
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            color: white;
                            font-weight: 600;
                            font-size: 0.875rem;
                        }

                        .spill-bucket {
                            position: absolute;
                            background: #ff9800;
                            border-radius: 50%;
                            animation: spillEffect 2s ease-in-out infinite;
                        }

                        @keyframes spillEffect {
                            0%, 100% { transform: scale(1); opacity: 0.7; }
                            50% { transform: scale(1.2); opacity: 1; }
                        }

                        .hotspot-indicator {
                            position: absolute;
                            background: var(--danger-emphasis);
                            border-radius: 50%;
                            animation: pulse 1s ease-in-out infinite;
                        }

                        @keyframes pulse {
                            0%, 100% { transform: scale(1); opacity: 0.8; }
                            50% { transform: scale(1.3); opacity: 1; }
                        }

                        .operation-chain {
                            display: flex;
                            align-items: center;
                            gap: 1rem;
                            margin-bottom: 1rem;
                            flex-wrap: wrap;
                        }

                        .chain-op {
                            padding: 0.5rem 1rem;
                            background: var(--bg-secondary);
                            border: 1px solid var(--border-default);
                            border-radius: 4px;
                            font-size: 0.875rem;
                            position: relative;
                        }

                        .chain-op.narrow {
                            border-bottom: 3px solid var(--success-emphasis);
                        }

                        .chain-op.wide {
                            border-bottom: 3px solid var(--attention-emphasis);
                        }

                        .chain-arrow {
                            color: var(--text-muted);
                            font-size: 1.25rem;
                        }

                        .stage-indicator {
                            position: absolute;
                            top: -8px;
                            right: -8px;
                            background: var(--accent-emphasis);
                            color: white;
                            border-radius: 50%;
                            width: 20px;
                            height: 20px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-size: 0.75rem;
                            font-weight: 600;
                        }

                        .metrics-grid {
                            display: grid;
                            grid-template-columns: 1fr 1fr;
                            gap: 1rem;
                        }

                        .metric-item {
                            display: flex;
                            justify-content: space-between;
                            padding: 0.5rem 0;
                            border-bottom: 1px solid var(--border-muted);
                        }

                        .metric-label {
                            font-weight: 500;
                            color: var(--text-primary);
                        }

                        .metric-value {
                            color: var(--text-secondary);
                            font-family: var(--font-mono);
                        }

                        .challenge-panel {
                            background: var(--accent-subtle);
                            border: 1px solid var(--accent-emphasis);
                            border-radius: 6px;
                            padding: 1rem;
                            margin-top: 1rem;
                        }

                        .challenge-title {
                            font-weight: 600;
                            color: var(--accent-fg);
                            margin-bottom: 0.5rem;
                        }

                        .challenge-status {
                            display: inline-block;
                            padding: 0.25rem 0.5rem;
                            border-radius: 4px;
                            font-size: 0.75rem;
                            font-weight: 500;
                            margin-left: 0.5rem;
                        }

                        .challenge-status.complete {
                            background: var(--success-emphasis);
                            color: white;
                        }

                        .challenge-status.incomplete {
                            background: var(--attention-emphasis);
                            color: white;
                        }

                        .slider-control {
                            margin: 1rem 0;
                        }

                        .slider-control label {
                            display: block;
                            margin-bottom: 0.5rem;
                            font-weight: 500;
                        }

                        .slider-control input[type="range"] {
                            width: 100%;
                            margin-bottom: 0.5rem;
                        }

                        .slider-value {
                            font-family: var(--font-mono);
                            color: var(--text-secondary);
                            font-size: 0.875rem;
                        }

                        .preset-buttons {
                            display: grid;
                            grid-template-columns: 1fr 1fr;
                            gap: 0.5rem;
                            margin-top: 1rem;
                        }

                        .preset-btn {
                            padding: 0.5rem;
                            border: 1px solid var(--border-default);
                            background: var(--bg-secondary);
                            color: var(--text-primary);
                            cursor: pointer;
                            border-radius: 4px;
                            font-size: 0.875rem;
                            transition: all 0.2s ease;
                        }

                        .preset-btn:hover {
                            background: var(--bg-accent);
                            border-color: var(--accent-emphasis);
                        }
                    </style>
                `;
            }

            setupEventListeners() {
                try {
                    // Route tabs
                    this.element.querySelectorAll('.route-tab').forEach(tab => {
                        tab.addEventListener('click', (e) => {
                            this.switchRoute(e.target.dataset.route);
                        });
                    });

                    // Control buttons
                    const resetBtn = this.element.querySelector('#resetBtn');
                    if (resetBtn) {
                        resetBtn.addEventListener('click', () => {
                            this.resetOperations();
                        });
                    }

                    const playBtn = this.element.querySelector('#playBtn');
                    if (playBtn) {
                        playBtn.addEventListener('click', () => {
                            this.animateFlow();
                        });
                    }

                    // Sliders
                    const partitionSlider = this.element.querySelector('#partitionCount');
                    if (partitionSlider) {
                        partitionSlider.addEventListener('input', (e) => {
                            this.partitionCount = parseInt(e.target.value);
                            const valueEl = this.element.querySelector('#partitionCountValue');
                            if (valueEl) valueEl.textContent = this.partitionCount;
                            this.updateVisualization();
                            this.updateMetrics();
                        });
                    }

                    const skewSlider = this.element.querySelector('#dataSkew');
                    if (skewSlider) {
                        skewSlider.addEventListener('input', (e) => {
                            this.dataSkew = parseInt(e.target.value);
                            const valueEl = this.element.querySelector('#dataSkewValue');
                            if (valueEl) valueEl.textContent = this.dataSkew + '%';
                            this.updateVisualization();
                            this.updateMetrics();
                            this.updateChallenges();
                        });
                    }

                    // Preset buttons
                    this.element.querySelectorAll('.preset-btn').forEach(btn => {
                        btn.addEventListener('click', (e) => {
                            this.applyPreset(e.target.dataset.preset);
                        });
                    });

                    // Close explanation button
                    const closeBtn = this.element.querySelector('#closeExplanation');
                    if (closeBtn) {
                        closeBtn.addEventListener('click', () => {
                            this.toggleExplanationPanel();
                        });
                    }
                } catch (error) {
                    // Gracefully handle cases where DOM is not available (testing)
                    console.log('Event listeners skipped - DOM not available');
                }
            }

            renderOperationPalette() {
                const palette = this.element.querySelector('#operationPalette');
                if (!palette) return;
                
                palette.innerHTML = '';

                Object.entries(this.operationTemplates).forEach(([key, op]) => {
                    const btn = document.createElement('button');
                    btn.className = `op-btn ${op.type}`;
                    btn.textContent = op.name;
                    btn.title = op.description;
                    btn.addEventListener('click', () => {
                        this.addOperation(key);
                    });
                    palette.appendChild(btn);
                });
            }

            addOperation(operationKey) {
                this.operations.push(operationKey);
                this.updateOperationChain();
                this.updateVisualization();
                this.updateMetrics();
                this.updateChallenges();
                this.api.announceToScreenReader(`Added ${operationKey} operation`);
            }

            removeOperation(index) {
                if (index >= 0 && index < this.operations.length) {
                    const removed = this.operations.splice(index, 1)[0];
                    this.updateOperationChain();
                    this.updateVisualization();
                    this.updateMetrics();
                    this.updateChallenges();
                    this.api.announceToScreenReader(`Removed ${removed} operation`);
                }
            }

            updateOperationChain() {
                const chain = this.element.querySelector('#operationChain');
                if (!chain) return;
                
                chain.innerHTML = '';

                if (this.operations.length === 0) {
                    chain.innerHTML = '<span style="color: var(--text-muted); font-style: italic;">No operations added yet</span>';
                    return;
                }

                this.operations.forEach((opKey, index) => {
                    const op = this.operationTemplates[opKey];
                    
                    if (index > 0) {
                        const arrow = document.createElement('span');
                        arrow.className = 'chain-arrow';
                        arrow.textContent = 'â†’';
                        chain.appendChild(arrow);
                    }

                    const opEl = document.createElement('div');
                    opEl.className = `chain-op ${op.type}`;
                    opEl.textContent = op.name;
                    opEl.style.cursor = 'pointer';
                    opEl.title = 'Click to remove';
                    opEl.addEventListener('click', () => {
                        this.removeOperation(index);
                    });

                    // Add stage indicator for wide operations
                    if (op.type === 'wide') {
                        const stageIndicator = document.createElement('div');
                        stageIndicator.className = 'stage-indicator';
                        stageIndicator.textContent = this.computeStageIdForOperation(index);
                        opEl.appendChild(stageIndicator);
                    }

                    chain.appendChild(opEl);
                });
            }

            updateVisualization() {
                const canvas = this.element.querySelector('#riverCanvas');
                if (!canvas) return;
                
                canvas.innerHTML = '';

                if (this.operations.length === 0) {
                    this.renderEmptyState(canvas);
                    return;
                }

                switch (this.currentRoute) {
                    case 'lineage-flow':
                        this.renderLineageFlow(canvas);
                        break;
                    case 'stage-boundaries':
                        this.renderStageBoundaries(canvas);
                        break;
                    case 'shuffle-anatomy':
                        this.renderShuffleAnatomy(canvas);
                        break;
                }
            }

            renderEmptyState(canvas) {
                const message = document.createElement('div');
                message.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    text-align: center;
                    color: var(--text-muted);
                    font-size: 1.125rem;
                `;
                message.innerHTML = `
                    <div style="font-size: 3rem; margin-bottom: 1rem;">ðŸŒŠ</div>
                    <div>Add operations from the palette to see the data flow</div>
                `;
                canvas.appendChild(message);
            }

            renderLineageFlow(canvas) {
                const canvasWidth = canvas.offsetWidth;
                const canvasHeight = canvas.offsetHeight;
                
                if (this.operations.length === 0) {
                    this.renderInitialPartitions(canvas, canvasWidth, canvasHeight);
                    return;
                }
                
                // Render step-by-step transformation
                this.renderTransformationFlow(canvas, canvasWidth, canvasHeight);
            }

            renderInitialPartitions(canvas, canvasWidth, canvasHeight) {
                const partitionWidth = Math.max(60, canvasWidth / (this.partitionCount + 1));
                const startY = 50;
                const partitionHeight = canvasHeight - 100;
                
                // Add title
                const title = document.createElement('div');
                title.style.cssText = `
                    position: absolute;
                    top: 10px;
                    left: 50%;
                    transform: translateX(-50%);
                    font-size: 16px;
                    font-weight: bold;
                    color: var(--text-primary);
                `;
                title.textContent = `Initial RDD with ${this.partitionCount} partitions`;
                canvas.appendChild(title);

                for (let i = 0; i < this.partitionCount; i++) {
                    const x = (i + 1) * (canvasWidth / (this.partitionCount + 1)) - partitionWidth / 2;
                    const intensity = this.getPartitionIntensity(i);
                    const recordCount = Math.ceil(intensity * 100);
                    
                    // Partition box
                    const partition = document.createElement('div');
                    partition.style.cssText = `
                        position: absolute;
                        left: ${x}px;
                        top: ${startY}px;
                        width: ${partitionWidth}px;
                        height: ${partitionHeight}px;
                        background: linear-gradient(to bottom, var(--river-blue), rgba(66, 133, 244, 0.7));
                        border: 2px solid var(--border-default);
                        border-radius: 8px;
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        justify-content: center;
                        color: white;
                        font-weight: bold;
                    `;
                    
                    partition.innerHTML = `
                        <div style="font-size: 14px;">Partition ${i}</div>
                        <div style="font-size: 18px; margin: 10px 0;">${recordCount}</div>
                        <div style="font-size: 12px;">records</div>
                    `;
                    
                    canvas.appendChild(partition);
                    
                    // Add hotspot indicator
                    if (this.isHotspotPartition(i)) {
                        const hotspot = document.createElement('div');
                        hotspot.className = 'hotspot-indicator';
                        hotspot.style.cssText = `
                            position: absolute;
                            top: ${startY - 15}px;
                            left: ${x + partitionWidth / 2 - 8}px;
                            width: 16px;
                            height: 16px;
                        `;
                        canvas.appendChild(hotspot);
                    }
                }
                
                // Add instruction
                const instruction = document.createElement('div');
                instruction.style.cssText = `
                    position: absolute;
                    bottom: 10px;
                    left: 50%;
                    transform: translateX(-50%);
                    font-size: 14px;
                    color: var(--text-secondary);
                    text-align: center;
                `;
                instruction.textContent = "Add operations from the palette to see how they transform the data flow";
                canvas.appendChild(instruction);
            }

            renderExplanationPanel(canvas, canvasWidth) {
                const panel = document.createElement('div');
                panel.style.cssText = `
                    position: absolute;
                    top: 10px;
                    left: 50%;
                    transform: translateX(-50%);
                    width: ${Math.min(canvasWidth - 40, 800)}px;
                    background: linear-gradient(135deg, var(--accent-subtle), var(--bg-secondary));
                    border: 2px solid var(--accent-emphasis);
                    border-radius: 8px;
                    padding: 12px 16px;
                    box-shadow: var(--shadow-medium);
                    z-index: 5;
                `;
                
                panel.innerHTML = `
                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <div style="font-size: 20px; margin-right: 10px;">ðŸŽ“</div>
                        <div style="font-size: 16px; font-weight: bold; color: var(--accent-fg);">
                            What You'll Learn: Lineage, Stages & Shuffles
                        </div>
                    </div>
                    <div style="font-size: 13px; line-height: 1.4; color: var(--text-primary);">
                        <strong>Understanding Spark's execution model:</strong>
                        <span style="color: var(--success-emphasis); font-weight: 600;">ðŸŸ¢ Narrow operations</span> (map, filter) keep data in same partitions - fast & local.
                        <span style="color: var(--attention-emphasis); font-weight: 600;">ðŸŸ¡ Wide operations</span> (groupBy, join) shuffle data across partitions - slow & network-intensive.
                        <span style="color: var(--danger-emphasis); font-weight: 600;">ðŸ”´ Stage boundaries</span> form where shuffles happen, breaking your job into stages.
                        <strong>ðŸ’¡ Key insight:</strong> Minimize wide operations and data skew for better performance!
                    </div>
                `;
                
                canvas.appendChild(panel);
            }

            renderTransformationFlow(canvas, canvasWidth, canvasHeight) {
                const stepHeight = Math.min(80, (canvasHeight - 40) / (this.operations.length + 1));
                const partitionWidth = Math.max(50, canvasWidth / (this.partitionCount + 1));
                const yOffset = 20;
                
                // Track data through each step
                let currentData = this.generateInitialPartitionData();
                
                // Render initial state
                this.renderTransformationStep(canvas, currentData, 0, stepHeight, partitionWidth, canvasWidth, null, 'Initial RDD', false, yOffset);
                
                // Render each operation step
                this.operations.forEach((opKey, index) => {
                    const operation = this.operationTemplates[opKey];
                    const stepY = (index + 1) * stepHeight + yOffset;
                    
                    // Transform data for this step
                    const previousData = [...currentData];
                    if (operation.type === 'narrow') {
                        currentData = this.simulateNarrowTransformation(currentData, operation);
                    } else {
                        currentData = this.simulateWideTransformation(currentData, operation);
                    }
                    
                    // Render the transformation step
                    this.renderTransformationStep(canvas, currentData, index + 1, stepHeight, partitionWidth, canvasWidth, operation, operation.name, false, yOffset);
                    
                    // Show data flow arrows between steps
                    this.renderDataFlowArrows(canvas, previousData, currentData, stepY - stepHeight, stepY, partitionWidth, canvasWidth, operation);
                });
            }

            renderTransformationStep(canvas, partitionData, stepIndex, height, partitionWidth, canvasWidth, operation, label, isAnimating = false, yOffset = 20) {
                const y = stepIndex * height + yOffset;
                
                // Step label
                const stepLabel = document.createElement('div');
                stepLabel.style.cssText = `
                    position: absolute;
                    left: 10px;
                    top: ${y + height/2 - 10}px;
                    background: ${operation ? (operation.type === 'narrow' ? 'var(--success-emphasis)' : 'var(--attention-emphasis)') : 'var(--text-secondary)'};
                    color: white;
                    padding: 4px 8px;
                    border-radius: 4px;
                    font-size: 12px;
                    font-weight: bold;
                    min-width: 60px;
                    text-align: center;
                `;
                stepLabel.textContent = label;
                canvas.appendChild(stepLabel);
                
                // Stage boundary for wide operations
                if (operation && operation.type === 'wide') {
                    const boundary = document.createElement('div');
                    boundary.style.cssText = `
                        position: absolute;
                        left: 80px;
                        top: ${y - 5}px;
                        width: ${canvasWidth - 100}px;
                        height: 3px;
                        background: var(--danger-emphasis);
                        z-index: 5;
                    `;
                    canvas.appendChild(boundary);
                    
                    const boundaryLabel = document.createElement('div');
                    boundaryLabel.style.cssText = `
                        position: absolute;
                        right: 10px;
                        top: -20px;
                        background: var(--danger-emphasis);
                        color: white;
                        padding: 2px 6px;
                        border-radius: 3px;
                        font-size: 10px;
                        font-weight: bold;
                    `;
                    boundaryLabel.textContent = 'STAGE BOUNDARY';
                    boundary.appendChild(boundaryLabel);
                }
                
                // Render partitions for this step
                partitionData.forEach((partition, i) => {
                    const x = 100 + i * (canvasWidth - 120) / this.partitionCount;
                    
                    const partitionBox = document.createElement('div');
                    partitionBox.style.cssText = `
                        position: absolute;
                        left: ${x}px;
                        top: ${y + 5}px;
                        width: ${partitionWidth}px;
                        height: ${height - 10}px;
                        background: ${partition.records > 0 ? 'var(--river-blue)' : 'var(--bg-accent)'};
                        border: 1px solid var(--border-default);
                        border-radius: 4px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        color: white;
                        font-weight: bold;
                        font-size: 12px;
                        opacity: ${partition.records > 0 ? 0.8 + (partition.records / 200) * 0.2 : 0.3};
                    `;
                    partitionBox.textContent = partition.records;
                    canvas.appendChild(partitionBox);
                    
                    // Hotspot indicator
                    if (partition.records > 150) {
                        const hotspot = document.createElement('div');
                        hotspot.className = 'hotspot-indicator';
                        hotspot.style.cssText = `
                            position: absolute;
                            top: ${y - 5}px;
                            left: ${x + partitionWidth/2 - 6}px;
                            width: 12px;
                            height: 12px;
                        `;
                        canvas.appendChild(hotspot);
                    }
                });
            }

            renderDataFlowArrows(canvas, fromData, toData, fromY, toY, partitionWidth, canvasWidth, operation) {
                const fromPositions = fromData.map((_, i) => 100 + i * (canvasWidth - 120) / this.partitionCount + partitionWidth/2);
                const toPositions = toData.map((_, i) => 100 + i * (canvasWidth - 120) / this.partitionCount + partitionWidth/2);
                
                if (operation.type === 'narrow') {
                    // Straight arrows for narrow operations
                    fromPositions.forEach((fromX, i) => {
                        const toX = toPositions[i];
                        if (fromData[i].records > 0) {
                            this.drawArrow(canvas, fromX, fromY + 60, toX, toY + 5, 'var(--success-emphasis)', 2);
                        }
                    });
                } else {
                    // Crossing arrows for wide operations (shuffle)
                    fromPositions.forEach((fromX, fromIndex) => {
                        if (fromData[fromIndex].records > 0) {
                            // Each partition can send data to multiple output partitions
                            toPositions.forEach((toX, toIndex) => {
                                const opacity = toData[toIndex].records > 0 ? 0.6 : 0.2;
                                this.drawArrow(canvas, fromX, fromY + 60, toX, toY + 5, 'var(--attention-emphasis)', 1, opacity);
                            });
                        }
                    });
                }
            }

            drawArrow(canvas, fromX, fromY, toX, toY, color, width = 2, opacity = 1) {
                const arrow = document.createElement('div');
                const length = Math.sqrt((toX - fromX) ** 2 + (toY - fromY) ** 2);
                const angle = Math.atan2(toY - fromY, toX - fromX) * 180 / Math.PI;
                
                arrow.style.cssText = `
                    position: absolute;
                    left: ${fromX}px;
                    top: ${fromY}px;
                    width: ${length}px;
                    height: ${width}px;
                    background: ${color};
                    transform-origin: 0 50%;
                    transform: rotate(${angle}deg);
                    opacity: ${opacity};
                    z-index: 1;
                `;
                canvas.appendChild(arrow);
                
                // Arrow head
                const arrowHead = document.createElement('div');
                arrowHead.style.cssText = `
                    position: absolute;
                    left: ${toX - 6}px;
                    top: ${toY - 3}px;
                    width: 0;
                    height: 0;
                    border-left: 6px solid ${color};
                    border-top: 3px solid transparent;
                    border-bottom: 3px solid transparent;
                    opacity: ${opacity};
                    z-index: 2;
                `;
                canvas.appendChild(arrowHead);
            }

            generateInitialPartitionData() {
                return Array.from({length: this.partitionCount}, (_, i) => ({
                    partitionId: i,
                    records: Math.ceil(this.getPartitionIntensity(i) * 100)
                }));
            }

            simulateNarrowTransformation(data, operation) {
                return data.map(partition => ({
                    ...partition,
                    records: this.applyOperationToCount(partition.records, operation)
                }));
            }

            simulateWideTransformation(data, operation) {
                const totalRecords = data.reduce((sum, p) => sum + p.records, 0);
                const transformedTotal = this.applyOperationToCount(totalRecords, operation);
                
                // Redistribute data (with potential skew)
                return Array.from({length: this.partitionCount}, (_, i) => {
                    let recordCount = Math.ceil(transformedTotal / this.partitionCount);
                    
                    // Apply skew to first partition if data skew is set
                    if (this.dataSkew > 0 && i === 0) {
                        recordCount = Math.ceil(transformedTotal * (0.3 + this.dataSkew * 0.008));
                    } else if (this.dataSkew > 0) {
                        const remaining = transformedTotal - Math.ceil(transformedTotal * (0.3 + this.dataSkew * 0.008));
                        recordCount = Math.ceil(remaining / (this.partitionCount - 1));
                    }
                    
                    return {
                        partitionId: i,
                        records: Math.max(0, recordCount)
                    };
                });
            }

            applyOperationToCount(count, operation) {
                switch (operation.name) {
                    case 'filter': return Math.ceil(count * 0.7);
                    case 'map': return count;
                    case 'sample': return Math.ceil(count * 0.5);
                    case 'flatMap': return Math.ceil(count * 1.3);
                    case 'groupBy': return count;
                    case 'join': return Math.ceil(count * 1.2);
                    case 'distinct': return Math.ceil(count * 0.8);
                    case 'sortBy': return count;
                    default: return count;
                }
            }

            calculateFlowSegments(canvasHeight) {
                const segments = [];
                const segmentHeight = Math.max(60, canvasHeight / Math.max(this.operations.length + 1, 4));
                
                // Start with initial data segment
                segments.push({
                    type: 'initial',
                    y: 20,
                    height: segmentHeight,
                    partitionData: this.generateInitialData(),
                    operation: null,
                    description: 'Initial RDD data'
                });
                
                // Add segment for each operation
                let currentPartitionData = this.generateInitialData();
                this.operations.forEach((opKey, index) => {
                    const op = this.operationTemplates[opKey];
                    const y = 20 + (index + 1) * segmentHeight;
                    
                    // Transform data based on operation type
                    if (op.type === 'narrow') {
                        // Narrow operations preserve partitioning
                        currentPartitionData = this.applyNarrowTransformation(currentPartitionData, op);
                    } else {
                        // Wide operations shuffle data
                        currentPartitionData = this.applyWideTransformation(currentPartitionData, op);
                    }
                    
                    segments.push({
                        type: op.type,
                        y: y,
                        height: segmentHeight,
                        partitionData: [...currentPartitionData],
                        operation: op,
                        operationKey: opKey,
                        description: this.getOperationDescription(op, currentPartitionData),
                        isStageBreak: op.type === 'wide'
                    });
                });
                
                return segments;
            }

            generateInitialData() {
                // Generate sample data for each partition
                const data = [];
                for (let i = 0; i < this.partitionCount; i++) {
                    const intensity = this.getPartitionIntensity(i);
                    const recordCount = Math.ceil(intensity * 100);
                    data.push({
                        partitionId: i,
                        records: recordCount,
                        sampleData: this.generateSampleRecords(recordCount, i)
                    });
                }
                return data;
            }

            generateSampleRecords(count, partitionId) {
                const records = [];
                for (let i = 0; i < Math.min(count, 10); i++) {
                    records.push({
                        id: `${partitionId}-${i}`,
                        value: Math.floor(Math.random() * 1000),
                        key: `key_${Math.floor(Math.random() * 50)}`
                    });
                }
                return records;
            }

            applyNarrowTransformation(partitionData, operation) {
                // Narrow operations process each partition independently
                return partitionData.map(partition => {
                    let newCount = partition.records;
                    
                    switch (operation.name) {
                        case 'filter':
                            newCount = Math.ceil(partition.records * 0.7); // Filter keeps ~70%
                            break;
                        case 'map':
                            // Map preserves count but transforms data
                            newCount = partition.records;
                            break;
                        case 'sample':
                            newCount = Math.ceil(partition.records * 0.5); // Sample keeps ~50%
                            break;
                        case 'flatMap':
                            newCount = Math.ceil(partition.records * 1.3); // FlatMap can expand
                            break;
                    }
                    
                    return {
                        ...partition,
                        records: newCount,
                        sampleData: this.generateSampleRecords(newCount, partition.partitionId)
                    };
                });
            }

            applyWideTransformation(partitionData, operation) {
                // Wide operations shuffle data across partitions
                const totalRecords = partitionData.reduce((sum, p) => sum + p.records, 0);
                const newData = [];
                
                for (let i = 0; i < this.partitionCount; i++) {
                    let newRecordCount;
                    
                    switch (operation.name) {
                        case 'groupBy':
                            // GroupBy redistributes based on keys
                            newRecordCount = Math.ceil(totalRecords / this.partitionCount);
                            if (this.dataSkew > 0 && i === 0) {
                                newRecordCount = Math.ceil(totalRecords * (0.3 + this.dataSkew * 0.006));
                            }
                            break;
                        case 'join':
                            // Join can increase data size
                            newRecordCount = Math.ceil(totalRecords * 1.2 / this.partitionCount);
                            break;
                        case 'distinct':
                            // Distinct reduces data size
                            newRecordCount = Math.ceil(totalRecords * 0.8 / this.partitionCount);
                            break;
                        case 'sortBy':
                            // Sort preserves count but redistributes
                            newRecordCount = Math.ceil(totalRecords / this.partitionCount);
                            break;
                        default:
                            newRecordCount = Math.ceil(totalRecords / this.partitionCount);
                    }
                    
                    newData.push({
                        partitionId: i,
                        records: newRecordCount,
                        sampleData: this.generateSampleRecords(newRecordCount, i)
                    });
                }
                
                return newData;
            }

            getOperationDescription(operation, partitionData) {
                const totalRecords = partitionData.reduce((sum, p) => sum + p.records, 0);
                const maxRecords = Math.max(...partitionData.map(p => p.records));
                const minRecords = Math.min(...partitionData.map(p => p.records));
                
                if (operation.type === 'narrow') {
                    return `${totalRecords} records, no shuffle`;
                } else {
                    const skewRatio = maxRecords / minRecords;
                    return `${totalRecords} records, shuffle (${skewRatio.toFixed(1)}x skew)`;
                }
            }

            renderFlowSegment(canvas, segment, segmentIndex, canvasWidth, streamWidth) {
                // Render partition streams for this segment
                segment.partitionData.forEach((partition, partitionIndex) => {
                    const stream = document.createElement('div');
                    stream.className = 'partition-stream';
                    
                    const x = (partitionIndex + 1) * (canvasWidth / (this.partitionCount + 1)) - streamWidth / 2;
                    const intensity = partition.records / 100; // Normalize to 0-1
                    const actualWidth = Math.max(8, streamWidth * Math.min(intensity, 1));
                    
                    stream.style.cssText = `
                        left: ${x}px;
                        top: ${segment.y}px;
                        width: ${actualWidth}px;
                        height: ${segment.height}px;
                        opacity: ${0.6 + Math.min(intensity * 0.4, 0.4)};
                        border: 1px solid rgba(0,0,0,0.1);
                    `;
                    
                    // Add data count label
                    const label = document.createElement('div');
                    label.style.cssText = `
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        font-size: 10px;
                        color: white;
                        font-weight: bold;
                        text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
                    `;
                    label.textContent = partition.records;
                    stream.appendChild(label);
                    
                    // Add data flow animation between segments
                    if (segmentIndex > 0 && segment.operation) {
                        this.addDataFlowAnimation(stream, segment);
                    }
                    
                    canvas.appendChild(stream);
                    
                    // Add hotspot indicator for skewed partitions
                    if (partition.records > 150) {
                        const hotspot = document.createElement('div');
                        hotspot.className = 'hotspot-indicator';
                        hotspot.style.cssText = `
                            left: ${x + actualWidth / 2 - 8}px;
                            top: ${segment.y - 8}px;
                            width: 16px;
                            height: 16px;
                        `;
                        canvas.appendChild(hotspot);
                    }
                });
                
                // Add stage boundary indicator for wide operations
                if (segment.isStageBreak) {
                    this.renderStageBoundary(canvas, segment, canvasWidth);
                }
            }

            addDataFlowAnimation(stream, segment) {
                if (segment.operation.type === 'wide') {
                    // Add shuffle animation for wide operations
                    stream.style.animation = 'shuffleEffect 2s ease-in-out infinite';
                } else {
                    // Add gentle flow for narrow operations
                    stream.style.animation = 'narrowFlow 3s ease-in-out infinite';
                }
            }

            renderStageBoundary(canvas, segment, canvasWidth) {
                const boundary = document.createElement('div');
                boundary.style.cssText = `
                    position: absolute;
                    left: 10px;
                    top: ${segment.y - 20}px;
                    width: ${canvasWidth - 20}px;
                    height: 2px;
                    background: var(--danger-emphasis);
                    z-index: 10;
                `;
                
                const label = document.createElement('div');
                label.style.cssText = `
                    position: absolute;
                    left: 10px;
                    top: -18px;
                    background: var(--danger-emphasis);
                    color: white;
                    padding: 2px 8px;
                    border-radius: 4px;
                    font-size: 12px;
                    font-weight: bold;
                `;
                label.textContent = `STAGE BOUNDARY - ${segment.operation.name.toUpperCase()}`;
                boundary.appendChild(label);
                
                canvas.appendChild(boundary);
            }

            renderOperationLabels(canvas, segments, canvasWidth) {
                segments.forEach(segment => {
                    if (segment.operation) {
                        const label = document.createElement('div');
                        label.style.cssText = `
                            position: absolute;
                            right: 10px;
                            top: ${segment.y + segment.height / 2 - 10}px;
                            background: ${segment.operation.type === 'narrow' ? 'var(--success-emphasis)' : 'var(--attention-emphasis)'};
                            color: white;
                            padding: 4px 8px;
                            border-radius: 4px;
                            font-size: 12px;
                            font-weight: bold;
                            max-width: 150px;
                        `;
                        label.innerHTML = `
                            <div>${segment.operation.name}</div>
                            <div style="font-size: 10px; opacity: 0.9;">${segment.description}</div>
                        `;
                        canvas.appendChild(label);
                    }
                });
            }

            renderStageBoundaries(canvas) {
                this.renderLineageFlow(canvas);
                
                // Add stage boundary indicators
                const stages = this.computeStages();
                const canvasWidth = canvas.offsetWidth;
                const canvasHeight = canvas.offsetHeight;

                stages.forEach((stage, index) => {
                    const stageLabel = document.createElement('div');
                    stageLabel.style.cssText = `
                        position: absolute;
                        top: 10px;
                        left: ${10 + index * 100}px;
                        background: var(--accent-emphasis);
                        color: white;
                        padding: 0.5rem 1rem;
                        border-radius: 4px;
                        font-weight: 600;
                        font-size: 0.875rem;
                    `;
                    stageLabel.textContent = `Stage ${index + 1} (${stage.taskCount} tasks)`;
                    canvas.appendChild(stageLabel);
                });
            }

            renderShuffleAnatomy(canvas) {
                this.renderLineageFlow(canvas);
                
                // Add spill buckets for shuffle operations
                this.operations.forEach((opKey, index) => {
                    const op = this.operationTemplates[opKey];
                    if (op.type === 'wide') {
                        this.renderSpillBuckets(canvas, index);
                    }
                });
            }

            renderDam(canvas, operationIndex, canvasWidth, canvasHeight) {
                const damHeight = 40;
                const damWidth = canvasWidth * 0.8;
                const y = (canvasHeight - damHeight) / 2 + operationIndex * 60;

                const dam = document.createElement('div');
                dam.className = 'stage-dam';
                dam.style.cssText = `
                    left: ${(canvasWidth - damWidth) / 2}px;
                    top: ${y}px;
                    width: ${damWidth}px;
                    height: ${damHeight}px;
                `;
                dam.textContent = this.operations[operationIndex].toUpperCase();
                canvas.appendChild(dam);
            }

            renderSpillBuckets(canvas, operationIndex) {
                const canvasWidth = canvas.offsetWidth;
                const canvasHeight = canvas.offsetHeight;

                for (let i = 0; i < this.partitionCount; i++) {
                    const bucket = document.createElement('div');
                    bucket.className = 'spill-bucket';
                    
                    const x = (i + 1) * (canvasWidth / (this.partitionCount + 1)) - 10;
                    const y = canvasHeight / 2 + operationIndex * 40;
                    
                    bucket.style.cssText = `
                        left: ${x}px;
                        top: ${y}px;
                        width: 20px;
                        height: 20px;
                    `;
                    
                    canvas.appendChild(bucket);
                }
            }

            getPartitionIntensity(partitionIndex) {
                if (this.dataSkew === 0) return 1.0;
                
                // Create skew pattern where early partitions get more data
                const skewFactor = this.dataSkew / 100;
                if (partitionIndex === 0) {
                    return 1.0; // Hotspot partition
                } else {
                    return Math.max(0.2, 1.0 - skewFactor * (partitionIndex / this.partitionCount));
                }
            }

            getMaxPartitionShare() {
                if (this.dataSkew === 0) return 100 / this.partitionCount;
                
                // Hotspot partition gets higher share
                const hotspotShare = 100 - (this.dataSkew * 0.8);
                const remainingShare = this.dataSkew * 0.8;
                return Math.max(hotspotShare, remainingShare / (this.partitionCount - 1));
            }

            isHotspotPartition(partitionIndex) {
                return this.dataSkew > 50 && partitionIndex === 0;
            }

            hasHotspotPartition() {
                return this.dataSkew > 50;
            }

            computeStageCount() {
                let stageCount = 1;
                this.operations.forEach(opKey => {
                    const op = this.operationTemplates[opKey];
                    if (op.type === 'wide') {
                        stageCount++;
                    }
                });
                return stageCount;
            }

            computeStageIdForOperation(operationIndex) {
                let stageId = 1;
                for (let i = 0; i <= operationIndex; i++) {
                    const op = this.operationTemplates[this.operations[i]];
                    if (op.type === 'wide') {
                        stageId++;
                    }
                }
                return stageId;
            }

            computeStages() {
                const stages = [];
                let currentStage = { operations: [], taskCount: this.partitionCount };
                
                this.operations.forEach((opKey, index) => {
                    const op = this.operationTemplates[opKey];
                    currentStage.operations.push(opKey);
                    
                    if (op.type === 'wide') {
                        stages.push({ ...currentStage });
                        currentStage = { operations: [], taskCount: this.partitionCount };
                    }
                });
                
                if (currentStage.operations.length > 0) {
                    stages.push(currentStage);
                }
                
                return stages.length > 0 ? stages : [{ operations: [], taskCount: this.partitionCount }];
            }

            updateMetrics() {
                const metricsGrid = this.element.querySelector('#metricsGrid');
                if (!metricsGrid) return;
                
                const stages = this.computeStages();
                const wideOps = this.operations.filter(opKey => this.operationTemplates[opKey].type === 'wide').length;
                const narrowOps = this.operations.filter(opKey => this.operationTemplates[opKey].type === 'narrow').length;
                const maxPartitionShare = this.getMaxPartitionShare();

                metricsGrid.innerHTML = `
                    <div class="metric-item">
                        <span class="metric-label">Total Stages</span>
                        <span class="metric-value">${stages.length}</span>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label">Wide Operations</span>
                        <span class="metric-value">${wideOps}</span>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label">Narrow Operations</span>
                        <span class="metric-value">${narrowOps}</span>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label">Max Partition Share</span>
                        <span class="metric-value">${Math.round(maxPartitionShare)}%</span>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label">Total Partitions</span>
                        <span class="metric-value">${this.partitionCount}</span>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label">Skew Factor</span>
                        <span class="metric-value">${this.dataSkew}%</span>
                    </div>
                `;
            }

            updateChallenges() {
                const challengePanel = this.element.querySelector('#challengePanel');
                if (!challengePanel) return;
                
                let completedCount = 0;
                let totalChallenges = this.challenges.size;
                
                let challengeHtml = '';
                this.challenges.forEach((challenge, key) => {
                    const isComplete = challenge.validator();
                    if (isComplete) completedCount++;
                    
                    challengeHtml += `
                        <div class="challenge-title">
                            ${challenge.title}
                            <span class="challenge-status ${isComplete ? 'complete' : 'incomplete'}">
                                ${isComplete ? 'âœ“' : 'â—‹'}
                            </span>
                        </div>
                        <div style="font-size: 0.875rem; color: var(--text-secondary); margin-bottom: 1rem;">
                            ${challenge.description}
                        </div>
                    `;
                });

                challengePanel.innerHTML = `
                    <div style="font-weight: 600; margin-bottom: 1rem;">
                        Challenges (${completedCount}/${totalChallenges} complete)
                    </div>
                    ${challengeHtml}
                `;
            }

            switchRoute(route) {
                this.currentRoute = route;
                
                // Update active tab
                this.element.querySelectorAll('.route-tab').forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.route === route);
                });
                
                this.updateVisualization();
                this.api.navigateToRoute(route);
                this.api.announceToScreenReader(`Switched to ${route} view`);
            }

            resetOperations() {
                this.operations = [];
                this.updateOperationChain();
                this.updateVisualization();
                this.updateMetrics();
                this.updateChallenges();
                this.api.announceToScreenReader('Operations reset');
            }

            animateFlow() {
                if (this.isAnimating || this.operations.length === 0) return;
                
                this.isAnimating = true;
                this.api.announceToScreenReader('Starting step-by-step data flow animation');
                
                // Clear current visualization
                const canvas = this.element.querySelector('#riverCanvas');
                canvas.innerHTML = '';
                
                // Animate step by step
                this.animateStepByStep(canvas);
            }

            animateStepByStep(canvas) {
                const canvasWidth = canvas.offsetWidth;
                const canvasHeight = canvas.offsetHeight;
                const stepHeight = Math.min(80, (canvasHeight - 40) / (this.operations.length + 1));
                const partitionWidth = Math.max(50, canvasWidth / (this.partitionCount + 1));
                const yOffset = 40;
                
                let currentData = this.generateInitialPartitionData();
                let currentStep = 0;
                
                // Add animation title
                const title = document.createElement('div');
                title.style.cssText = `
                    position: absolute;
                    top: 10px;
                    left: 50%;
                    transform: translateX(-50%);
                    font-size: 16px;
                    font-weight: bold;
                    color: var(--accent-emphasis);
                    z-index: 10;
                `;
                title.textContent = 'ðŸ“Š Data Flow Animation - Step by Step';
                canvas.appendChild(title);
                
                // Function to animate each step
                const animateStep = () => {
                    if (currentStep <= this.operations.length) {
                        if (currentStep === 0) {
                            // Initial step
                            this.renderAnimatedStep(canvas, currentData, currentStep, stepHeight, partitionWidth, canvasWidth, null, 'Initial RDD', true, yOffset);
                        } else {
                            // Operation step
                            const operation = this.operationTemplates[this.operations[currentStep - 1]];
                            const previousData = [...currentData];
                            
                            if (operation.type === 'narrow') {
                                currentData = this.simulateNarrowTransformation(currentData, operation);
                            } else {
                                currentData = this.simulateWideTransformation(currentData, operation);
                            }
                            
                            this.renderAnimatedStep(canvas, currentData, currentStep, stepHeight, partitionWidth, canvasWidth, operation, operation.name, true, yOffset);
                            
                            // Add flowing data animation
                            setTimeout(() => {
                                this.addFlowingDataAnimation(canvas, previousData, currentData, (currentStep - 1) * stepHeight + yOffset, currentStep * stepHeight + yOffset, partitionWidth, canvasWidth, operation);
                            }, 500);
                        }
                        
                        currentStep++;
                        setTimeout(animateStep, 2000); // Wait 2 seconds before next step
                    } else {
                        // Animation complete
                        setTimeout(() => {
                            this.isAnimating = false;
                            this.updateVisualization(); // Return to normal view
                        }, 2000);
                    }
                };
                
                animateStep();
            }

            renderAnimatedStep(canvas, partitionData, stepIndex, stepHeight, partitionWidth, canvasWidth, operation, label, isAnimating = false, yOffset = 20) {
                const y = stepIndex * stepHeight + yOffset;
                
                // Step label with animation
                const stepLabel = document.createElement('div');
                stepLabel.style.cssText = `
                    position: absolute;
                    left: 10px;
                    top: ${y + stepHeight/2 - 10}px;
                    background: ${operation ? (operation.type === 'narrow' ? 'var(--success-emphasis)' : 'var(--attention-emphasis)') : 'var(--text-secondary)'};
                    color: white;
                    padding: 6px 12px;
                    border-radius: 6px;
                    font-size: 14px;
                    font-weight: bold;
                    min-width: 80px;
                    text-align: center;
                    box-shadow: var(--shadow-medium);
                    animation: ${isAnimating ? 'stepAppear 0.5s ease-out' : 'none'};
                `;
                stepLabel.textContent = `${stepIndex + 1}. ${label}`;
                canvas.appendChild(stepLabel);
                
                // Stage boundary for wide operations
                if (operation && operation.type === 'wide') {
                    const boundary = document.createElement('div');
                    boundary.style.cssText = `
                        position: absolute;
                        left: 100px;
                        top: ${y - 5}px;
                        width: ${canvasWidth - 120}px;
                        height: 4px;
                        background: linear-gradient(90deg, var(--danger-emphasis), #ff6b6b);
                        z-index: 5;
                        border-radius: 2px;
                        animation: ${isAnimating ? 'stageBoundaryAppear 0.8s ease-out 0.3s both' : 'none'};
                    `;
                    canvas.appendChild(boundary);
                    
                    const boundaryLabel = document.createElement('div');
                    boundaryLabel.style.cssText = `
                        position: absolute;
                        right: 0px;
                        top: -25px;
                        background: var(--danger-emphasis);
                        color: white;
                        padding: 3px 8px;
                        border-radius: 4px;
                        font-size: 11px;
                        font-weight: bold;
                        animation: ${isAnimating ? 'pulse 1s ease-in-out infinite 1s' : 'none'};
                    `;
                    boundaryLabel.textContent = 'ðŸš« STAGE BOUNDARY';
                    boundary.appendChild(boundaryLabel);
                }
                
                // Render animated partitions
                partitionData.forEach((partition, i) => {
                    const x = 100 + i * (canvasWidth - 120) / this.partitionCount;
                    
                    const partitionBox = document.createElement('div');
                    partitionBox.style.cssText = `
                        position: absolute;
                        left: ${x}px;
                        top: ${y + 10}px;
                        width: ${partitionWidth}px;
                        height: ${stepHeight - 20}px;
                        background: ${partition.records > 0 ? 
                            `linear-gradient(135deg, var(--river-blue), rgba(66, 133, 244, 0.7))` : 
                            'var(--bg-accent)'};
                        border: 2px solid ${partition.records > 150 ? 'var(--danger-emphasis)' : 'var(--border-default)'};
                        border-radius: 6px;
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        justify-content: center;
                        color: white;
                        font-weight: bold;
                        font-size: 11px;
                        opacity: ${partition.records > 0 ? 0.9 : 0.4};
                        box-shadow: var(--shadow-small);
                        animation: ${isAnimating ? `partitionUpdate 0.6s ease-out ${i * 0.1}s both` : 'none'};
                        transition: all 0.3s ease;
                    `;
                    
                    partitionBox.innerHTML = `
                        <div style="font-size: 9px; opacity: 0.8;">P${i}</div>
                        <div style="font-size: 14px; margin: 2px 0;">${partition.records}</div>
                        <div style="font-size: 8px; opacity: 0.8;">records</div>
                    `;
                    
                    canvas.appendChild(partitionBox);
                    
                    // Hotspot indicator with animation
                    if (partition.records > 150) {
                        const hotspot = document.createElement('div');
                        hotspot.style.cssText = `
                            position: absolute;
                            top: ${y + 5}px;
                            left: ${x + partitionWidth/2 - 8}px;
                            width: 16px;
                            height: 16px;
                            background: var(--danger-emphasis);
                            border-radius: 50%;
                            animation: hotspotAlert 1s ease-in-out infinite;
                            z-index: 6;
                        `;
                        hotspot.textContent = 'ðŸ”¥';
                        hotspot.style.fontSize = '10px';
                        hotspot.style.textAlign = 'center';
                        hotspot.style.lineHeight = '16px';
                        canvas.appendChild(hotspot);
                    }
                });
            }

            addFlowingDataAnimation(canvas, fromData, toData, fromY, toY, partitionWidth, canvasWidth, operation) {
                const fromPositions = fromData.map((_, i) => 100 + i * (canvasWidth - 120) / this.partitionCount + partitionWidth/2);
                const toPositions = toData.map((_, i) => 100 + i * (canvasWidth - 120) / this.partitionCount + partitionWidth/2);
                
                if (operation.type === 'narrow') {
                    // Straight flowing data for narrow operations
                    fromPositions.forEach((fromX, i) => {
                        const toX = toPositions[i];
                        if (fromData[i].records > 0) {
                            this.createFlowingData(canvas, fromX, fromY + 50, toX, toY + 10, 'var(--success-emphasis)', false);
                        }
                    });
                } else {
                    // Shuffling data for wide operations
                    const delay = 200;
                    fromPositions.forEach((fromX, fromIndex) => {
                        if (fromData[fromIndex].records > 0) {
                            toPositions.forEach((toX, toIndex) => {
                                if (toData[toIndex].records > 0) {
                                    setTimeout(() => {
                                        this.createFlowingData(canvas, fromX, fromY + 50, toX, toY + 10, 'var(--attention-emphasis)', true);
                                    }, fromIndex * delay + toIndex * 50);
                                }
                            });
                        }
                    });
                }
            }

            createFlowingData(canvas, fromX, fromY, toX, toY, color, isShuffle) {
                const dataParticle = document.createElement('div');
                dataParticle.style.cssText = `
                    position: absolute;
                    left: ${fromX - 3}px;
                    top: ${fromY}px;
                    width: 6px;
                    height: 6px;
                    background: ${color};
                    border-radius: 50%;
                    z-index: 8;
                    box-shadow: 0 0 4px ${color};
                `;
                
                canvas.appendChild(dataParticle);
                
                // Animate particle movement
                const deltaX = toX - fromX;
                const deltaY = toY - fromY;
                const duration = isShuffle ? 1500 : 800;
                
                dataParticle.animate([
                    { transform: 'translate(0, 0)', opacity: 1 },
                    { transform: `translate(${deltaX}px, ${deltaY}px)`, opacity: 0.8 }
                ], {
                    duration: duration,
                    easing: isShuffle ? 'cubic-bezier(0.4, 0, 0.6, 1)' : 'ease-out'
                }).addEventListener('finish', () => {
                    dataParticle.remove();
                });
            }

            toggleExplanationPanel() {
                const panel = this.element.querySelector('#explanationPanel');
                if (panel) {
                    panel.classList.toggle('hidden');
                    this.api.announceToScreenReader(
                        panel.classList.contains('hidden') ? 
                        'Explanation panel hidden' : 
                        'Explanation panel shown'
                    );
                }
            }

            applyPreset(preset) {
                switch (preset) {
                    case 'balanced':
                        this.dataSkew = 0;
                        this.partitionCount = 4;
                        break;
                    case 'skewed':
                        this.dataSkew = 60;
                        this.partitionCount = 6;
                        break;
                    case 'extreme':
                        this.dataSkew = 90;
                        this.partitionCount = 8;
                        break;
                    case 'custom':
                        // Keep current settings
                        break;
                }
                
                // Update UI
                const skewSlider = this.element.querySelector('#dataSkew');
                const skewValue = this.element.querySelector('#dataSkewValue');
                const partitionSlider = this.element.querySelector('#partitionCount');
                const partitionValue = this.element.querySelector('#partitionCountValue');
                
                if (skewSlider) skewSlider.value = this.dataSkew;
                if (skewValue) skewValue.textContent = this.dataSkew + '%';
                if (partitionSlider) partitionSlider.value = this.partitionCount;
                if (partitionValue) partitionValue.textContent = this.partitionCount;
                
                this.updateVisualization();
                this.updateMetrics();
                this.updateChallenges();
                this.api.announceToScreenReader(`Applied ${preset} preset`);
            }

            // Test methods for validation
            runTests() {
                const tests = [];
                
                // Test 1: Fixed op chain creates expected stage count
                tests.push({
                    name: 'Stage count calculation',
                    run: () => {
                        const originalOps = [...this.operations];
                        this.operations = ['map', 'filter', 'groupBy', 'map'];
                        const stageCount = this.computeStageCount();
                        this.operations = originalOps;
                        return stageCount === 2; // 1 initial + 1 after groupBy
                    }
                });
                
                // Test 2: Skew preset raises max partition share above threshold
                tests.push({
                    name: 'Skew hotspot detection',
                    run: () => {
                        const originalSkew = this.dataSkew;
                        this.dataSkew = 80;
                        const maxShare = this.getMaxPartitionShare();
                        this.dataSkew = originalSkew;
                        return maxShare > 30; // Should be higher than balanced distribution
                    }
                });
                
                // Test 3: Removing wide op reduces stage count
                tests.push({
                    name: 'Wide operation stage impact',
                    run: () => {
                        const originalOps = [...this.operations];
                        this.operations = ['map', 'groupBy', 'filter'];
                        const withWide = this.computeStageCount();
                        this.operations = ['map', 'filter'];
                        const withoutWide = this.computeStageCount();
                        this.operations = originalOps;
                        return withWide > withoutWide;
                    }
                });
                
                return tests;
            }
        }

        // Register the Lineage, Stages & Shuffles module
        window.SparkLab.registerModule({
            id: 'lineage-stages-shuffles',
            title: 'Lineage, Stages & Shuffles',
            subtitle: 'Visualize data flow through river metaphor',
            icon: 'ðŸŒŠ',
            routes: [
                { id: 'lineage-flow', label: 'Lineage Flow' },
                { id: 'stage-boundaries', label: 'Stage Boundaries' },
                { id: 'shuffle-anatomy', label: 'Shuffle Anatomy' }
            ],
            init(element, api) {
                const module = new LineageStagesShufflesModule(element, api);
                window.lineageStagesShufflesModule = module;
                module.init();
            },
            tests() {
                if (window.lineageStagesShufflesModule) {
                    return window.lineageStagesShufflesModule.runTests();
                }
                return [];
            },
            about: {
                learningOutcomes: [
                    'Understand the difference between narrow and wide transformations',
                    'Visualize how wide operations create stage boundaries',
                    'Recognize data skew and hotspot partitions',
                    'Understand shuffle mechanics in distributed computing',
                    'Learn how partitioning affects performance'
                ],
                references: [
                    'Apache Spark Stage Boundaries',
                    'Data Skew Mitigation Strategies',
                    'Shuffle Operations in Distributed Systems'
                ]
            }
        });

        window.SparkLab.registerModule({
            id: 'rdd-lineage',
            title: 'RDD Lineage',
            subtitle: 'Visualize transformation dependencies',
            icon: 'ðŸ”—',
            routes: [
                { id: 'playground', label: 'Interactive Playground' },
                { id: 'challenges', label: 'Learning Challenges' },
                { id: 'examples', label: 'Real-world Examples' }
            ],
            init(element, api) {
                const module = new RDDLineageModule(element, api);
                window.rddLineageModule = module;
                module.init();
            },
            tests() {
                return [
                    {
                        name: 'Module renders without errors',
                        run() {
                            return document.getElementById('module-rdd-lineage') !== null;
                        }
                    },
                    {
                        name: 'DAG visualization container exists',
                        run() {
                            return document.querySelector('#rdd-dag-container') !== null;
                        }
                    },
                    {
                        name: 'Operations panel exists',
                        run() {
                            return document.querySelector('#rdd-operations-panel') !== null;
                        }
                    },
                    {
                        name: 'Initial RDD is created',
                        run() {
                            return window.rddLineageModule && window.rddLineageModule.rdds.size > 0;
                        }
                    }
                ];
            },
            about: {
                learningOutcomes: [
                    'Understand RDD transformation lineage and dependencies',
                    'Visualize how operations create new RDDs',
                    'Identify wide vs narrow transformations',
                    'Recognize stage boundaries and shuffles',
                    'Optimize transformation chains for performance'
                ],
                references: [
                    'Apache Spark RDD Programming Guide',
                    'Spark Performance Tuning',
                    'Resilient Distributed Datasets Paper'
                ]
            }
        });

        window.SparkLab.registerModule({
            id: 'data-partitioning',
            title: 'Data Partitioning',
            subtitle: 'Visualize data distribution strategies',
            icon: 'ðŸ­',
            routes: [
                { id: 'hash', label: 'Hash Partitioning' },
                { id: 'range', label: 'Range Partitioning' },
                { id: 'custom', label: 'Custom Partitioning' },
                { id: 'challenges', label: 'Challenges' }
            ],
            init(element, api) {
                const partitioningModule = new DataPartitioningModule(element, api);
                window.partitioningModule = partitioningModule;
                partitioningModule.init();
            },
            tests() {
                return [
                    {
                        name: 'Module renders without errors',
                        run() {
                            return document.getElementById('module-data-partitioning') !== null;
                        }
                    },
                    {
                        name: 'Conveyor belt visualization exists',
                        run() {
                            return document.querySelector('#partitioning-conveyor') !== null;
                        }
                    },
                    {
                        name: 'Partition controls exist',
                        run() {
                            return document.querySelector('#partition-controls') !== null;
                        }
                    }
                ];
            },
            about: {
                learningOutcomes: [
                    'Visualize how data distributes across cluster nodes',
                    'Understand partitioning strategies (hash, range, custom)',
                    'Recognize data skew and load balancing issues',
                    'Design optimal partitioning for different workloads'
                ],
                references: [
                    'Spark Partitioning Deep Dive',
                    'Data Skew Mitigation Strategies',
                    'Consistent Hashing in Distributed Systems'
                ]
            }
        });

        window.SparkLab.registerModule({
            id: 'shuffle-simulator',
            title: 'Shuffle Operations',
            subtitle: 'Explore data movement patterns',
            icon: 'ðŸ”„',
            routes: [
                { id: 'hash-shuffle', label: 'Hash Shuffle' },
                { id: 'sort-shuffle', label: 'Sort Shuffle' },
                { id: 'optimization', label: 'Optimization' }
            ],
            init(element, api) {
                element.innerHTML = `
                    <div style="padding: 2rem;">
                        <h1>Shuffle Operations Simulator</h1>
                        <p>This is a placeholder for the Shuffle Operations module.</p>
                        <p>Current route: ${api.getCurrentRoute()}</p>
                        <div style="margin-top: 1rem; padding: 1rem; background: var(--bg-accent); border-radius: 6px;">
                            <h3>Simulation Features</h3>
                            <ul>
                                <li>Data partitioning visualization</li>
                                <li>Network traffic simulation</li>
                                <li>Shuffle read/write metrics</li>
                                <li>Performance comparison tools</li>
                            </ul>
                        </div>
                    </div>
                `;
            },
            tests() {
                return [
                    {
                        name: 'Module renders without errors',
                        run() {
                            return document.getElementById('module-shuffle-simulator') !== null;
                        }
                    }
                ];
            },
            about: {
                learningOutcomes: [
                    'Understand shuffle mechanics',
                    'Compare shuffle strategies',
                    'Optimize shuffle performance'
                ],
                references: [
                    'Spark Shuffle Internals',
                    'Tungsten Shuffle Service'
                ]
            }
        });
    </script>
</body>
</html>